/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { Directive, EventEmitter, Input, Output } from '@angular/core';
import { Subject } from 'rxjs';
import { transition } from 'd3-transition';
import { zoom, zoomIdentity, zoomTransform } from 'd3-zoom';
import { numberAttributeWithOneFallback } from 'ng-zorro-antd/core/util';
import { calculateTransform } from './core/utils';
import * as i0 from "@angular/core";
export class NzGraphZoomDirective {
    constructor(element, cdr) {
        this.element = element;
        this.cdr = cdr;
        this.nzMinZoom = 0.1;
        this.nzMaxZoom = 10;
        this.nzTransformEvent = new EventEmitter();
        this.nzZoomChange = new EventEmitter();
        this.destroy$ = new Subject();
    }
    ngAfterViewInit() {
        this.bind();
    }
    ngOnDestroy() {
        this.unbind();
        this.destroy$.next();
        this.destroy$.complete();
    }
    bind() {
        this.svgElement = this.element.nativeElement.querySelector('svg');
        this.gZoomElement = this.element.nativeElement.querySelector('svg > g');
        const { width, height } = this.element.nativeElement.getBoundingClientRect();
        this.svgSelection = transition()
            .selection()
            .select(() => this.svgElement);
        this.zoomBehavior = zoom()
            .extent([
            [0, 0],
            [width, height]
        ])
            .scaleExtent([this.nzMinZoom, this.nzMaxZoom])
            .on('zoom', e => {
            this.zoomed(e);
        });
        this.svgSelection.call(this.zoomBehavior, zoomIdentity.translate(0, 0).scale(this.nzZoom || 1));
        // Init with nzZoom
        this.reScale(0, this.nzZoom);
    }
    unbind() {
        // Destroy listener
        this.svgSelection?.interrupt().selectAll('*').interrupt();
        if (this.zoomBehavior) {
            this.zoomBehavior.on('end', null).on('zoom', null);
        }
    }
    // Methods
    fitCenter(duration = 0) {
        this.reScale(duration);
    }
    focus(id, duration = 0) {
        // Make sure this node is under SVG container
        if (!this.svgElement.getElementById(`${id}`)) {
            return;
        }
        const node = this.svgElement.getElementById(`${id}`);
        const svgRect = this.svgElement.getBoundingClientRect();
        const position = this.getRelativePositionInfo(node);
        const svgTransform = zoomTransform(this.svgElement);
        const centerX = (position.topLeft.x + position.bottomRight.x) / 2;
        const centerY = (position.topLeft.y + position.bottomRight.y) / 2;
        const dx = svgRect.left + svgRect.width / 2 - centerX;
        const dy = svgRect.top + svgRect.height / 2 - centerY;
        this.svgSelection
            .transition()
            .duration(duration)
            .call(this.zoomBehavior.translateBy, dx / svgTransform.k, dy / svgTransform.k);
    }
    /**
     * Handle zoom event
     *
     * @param transform
     */
    zoomed({ transform }) {
        const { x, y, k } = transform;
        // Update g element transform
        this.gZoomElement.setAttribute('transform', `translate(${x}, ${y})scale(${k})`);
        this.nzZoom = k;
        this.nzZoomChange.emit(this.nzZoom);
        this.nzTransformEvent.emit(transform);
        this.cdr.markForCheck();
    }
    /**
     * Scale with zoom and duration
     *
     * @param duration
     * @param scale
     * @private
     */
    reScale(duration, scale) {
        const transform = calculateTransform(this.svgElement, this.gZoomElement, scale);
        if (!transform) {
            return;
        }
        const { x, y, k } = transform;
        const zTransform = zoomIdentity.translate(x, y).scale(Math.max(k, this.nzMinZoom));
        this.svgSelection
            .transition()
            .duration(duration)
            .call(this.zoomBehavior.transform, zTransform)
            .on('end.fitted', () => {
            this.zoomBehavior.on('end.fitted', null);
        });
    }
    getRelativePositionInfo(node) {
        const nodeBox = node.getBBox();
        const nodeCtm = node.getScreenCTM();
        let pointTL = this.svgElement.createSVGPoint();
        let pointBR = this.svgElement.createSVGPoint();
        pointTL.x = nodeBox.x;
        pointTL.y = nodeBox.y;
        pointBR.x = nodeBox.x + nodeBox.width;
        pointBR.y = nodeBox.y + nodeBox.height;
        pointTL = pointTL.matrixTransform(nodeCtm);
        pointBR = pointBR.matrixTransform(nodeCtm);
        return {
            topLeft: pointTL,
            bottomRight: pointBR
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: NzGraphZoomDirective, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "18.1.2", type: NzGraphZoomDirective, isStandalone: true, selector: "[nz-graph-zoom]", inputs: { nzZoom: ["nzZoom", "nzZoom", numberAttributeWithOneFallback], nzMinZoom: "nzMinZoom", nzMaxZoom: "nzMaxZoom" }, outputs: { nzTransformEvent: "nzTransformEvent", nzZoomChange: "nzZoomChange" }, exportAs: ["nzGraphZoom"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: NzGraphZoomDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nz-graph-zoom]',
                    exportAs: 'nzGraphZoom',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }], propDecorators: { nzZoom: [{
                type: Input,
                args: [{ transform: numberAttributeWithOneFallback }]
            }], nzMinZoom: [{
                type: Input
            }], nzMaxZoom: [{
                type: Input
            }], nzTransformEvent: [{
                type: Output
            }], nzZoomChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JhcGgtem9vbS5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9jb21wb25lbnRzL2dyYXBoL2dyYXBoLXpvb20uZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRztBQUVILE9BQU8sRUFHTCxTQUFTLEVBRVQsWUFBWSxFQUNaLEtBQUssRUFFTCxNQUFNLEVBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUcvQixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxJQUFJLEVBQWdCLFlBQVksRUFBRSxhQUFhLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFHMUUsT0FBTyxFQUFFLDhCQUE4QixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFFekUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sY0FBYyxDQUFDOztBQVFsRCxNQUFNLE9BQU8sb0JBQW9CO0lBa0IvQixZQUNVLE9BQW1CLEVBQ25CLEdBQXNCO1FBRHRCLFlBQU8sR0FBUCxPQUFPLENBQVk7UUFDbkIsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFsQnZCLGNBQVMsR0FBRyxHQUFHLENBQUM7UUFDaEIsY0FBUyxHQUFHLEVBQUUsQ0FBQztRQUVMLHFCQUFnQixHQUFrQyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBQ3JFLGlCQUFZLEdBQXlCLElBQUksWUFBWSxFQUFFLENBQUM7UUFVbkUsYUFBUSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7SUFLcEMsQ0FBQztJQUVKLGVBQWU7UUFDYixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDZCxDQUFDO0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNkLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLFFBQVEsQ0FB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QUMsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO1FBQ3RDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDO1FBQ3ZDLE9BQU8sR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLE9BQVEsQ0FBQyxDQUFDO1FBQzVDLE9BQU8sR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLE9BQVEsQ0FBQyxDQUFDO1FBQzVDLE9BQU87WUFDTCxPQUFPLEVBQUUsT0FBTztZQUNoQixXQUFXLEVBQUUsT0FBTztTQUNyQixDQUFDO0lBQ0osQ0FBQzs4R0EvSVUsb0JBQW9CO2tHQUFwQixvQkFBb0IsMEZBQ1gsOEJBQThCOzsyRkFEdkMsb0JBQW9CO2tCQUxoQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxpQkFBaUI7b0JBQzNCLFFBQVEsRUFBRSxhQUFhO29CQUN2QixVQUFVLEVBQUUsSUFBSTtpQkFDakI7K0dBRXVELE1BQU07c0JBQTNELEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsOEJBQThCLEVBQUU7Z0JBQzNDLFNBQVM7c0JBQWpCLEtBQUs7Z0JBQ0csU0FBUztzQkFBakIsS0FBSztnQkFFYSxnQkFBZ0I7c0JBQWxDLE1BQU07Z0JBQ1ksWUFBWTtzQkFBOUIsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9naXRodWIuY29tL05HLVpPUlJPL25nLXpvcnJvLWFudGQvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbmltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT3V0cHV0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBTZWxlY3Rpb24gfSBmcm9tICdkMy1zZWxlY3Rpb24nO1xuaW1wb3J0IHsgdHJhbnNpdGlvbiB9IGZyb20gJ2QzLXRyYW5zaXRpb24nO1xuaW1wb3J0IHsgem9vbSwgWm9vbUJlaGF2aW9yLCB6b29tSWRlbnRpdHksIHpvb21UcmFuc2Zvcm0gfSBmcm9tICdkMy16b29tJztcblxuaW1wb3J0IHsgTnpTYWZlQW55IH0gZnJvbSAnbmctem9ycm8tYW50ZC9jb3JlL3R5cGVzJztcbmltcG9ydCB7IG51bWJlckF0dHJpYnV0ZVdpdGhPbmVGYWxsYmFjayB9IGZyb20gJ25nLXpvcnJvLWFudGQvY29yZS91dGlsJztcblxuaW1wb3J0IHsgY2FsY3VsYXRlVHJhbnNmb3JtIH0gZnJvbSAnLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IE56Wm9vbVRyYW5zZm9ybSwgUmVsYXRpdmVQb3NpdGlvbkluZm8gfSBmcm9tICcuL2ludGVyZmFjZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tuei1ncmFwaC16b29tXScsXG4gIGV4cG9ydEFzOiAnbnpHcmFwaFpvb20nLFxuICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIE56R3JhcGhab29tRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBBZnRlclZpZXdJbml0IHtcbiAgQElucHV0KHsgdHJhbnNmb3JtOiBudW1iZXJBdHRyaWJ1dGVXaXRoT25lRmFsbGJhY2sgfSkgbnpab29tPzogbnVtYmVyO1xuICBASW5wdXQoKSBuek1pblpvb20gPSAwLjE7XG4gIEBJbnB1dCgpIG56TWF4Wm9vbSA9IDEwO1xuXG4gIEBPdXRwdXQoKSByZWFkb25seSBuelRyYW5zZm9ybUV2ZW50OiBFdmVudEVtaXR0ZXI8Tnpab29tVHJhbnNmb3JtPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IG56Wm9vbUNoYW5nZTogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgc3ZnU2VsZWN0aW9uITogU2VsZWN0aW9uPE56U2FmZUFueSwgTnpTYWZlQW55LCBOelNhZmVBbnksIE56U2FmZUFueT47XG4gIHpvb21CZWhhdmlvciE6IFpvb21CZWhhdmlvcjxOelNhZmVBbnksIE56U2FmZUFueT47XG5cbiAgLy8gVE9ET1xuICAvLyBTdXBwb3J0IHN2ZyBlbGVtZW50IG9ubHkgbm93XG4gIHN2Z0VsZW1lbnQhOiBTVkdTVkdFbGVtZW50O1xuICBnWm9vbUVsZW1lbnQhOiBTVkdHRWxlbWVudDtcblxuICBwcml2YXRlIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmXG4gICkge31cblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgdGhpcy5iaW5kKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnVuYmluZCgpO1xuICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgfVxuXG4gIGJpbmQoKTogdm9pZCB7XG4gICAgdGhpcy5zdmdFbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3Rvcignc3ZnJykgYXMgU1ZHU1ZHRWxlbWVudDtcbiAgICB0aGlzLmdab29tRWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N2ZyA+IGcnKSBhcyBTVkdHRWxlbWVudDtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuc3ZnU2VsZWN0aW9uID0gdHJhbnNpdGlvbigpXG4gICAgICAuc2VsZWN0aW9uKClcbiAgICAgIC5zZWxlY3QoKCkgPT4gdGhpcy5zdmdFbGVtZW50KTtcbiAgICB0aGlzLnpvb21CZWhhdmlvciA9IHpvb20oKVxuICAgICAgLmV4dGVudChbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgW3dpZHRoLCBoZWlnaHRdXG4gICAgICBdKVxuICAgICAgLnNjYWxlRXh0ZW50KFt0aGlzLm56TWluWm9vbSwgdGhpcy5uek1heFpvb21dKVxuICAgICAgLm9uKCd6b29tJywgZSA9PiB7XG4gICAgICAgIHRoaXMuem9vbWVkKGUpO1xuICAgICAgfSk7XG4gICAgdGhpcy5zdmdTZWxlY3Rpb24uY2FsbCh0aGlzLnpvb21CZWhhdmlvciwgem9vbUlkZW50aXR5LnRyYW5zbGF0ZSgwLCAwKS5zY2FsZSh0aGlzLm56Wm9vbSB8fCAxKSk7XG4gICAgLy8gSW5pdCB3aXRoIG56Wm9vbVxuICAgIHRoaXMucmVTY2FsZSgwLCB0aGlzLm56Wm9vbSk7XG4gIH1cblxuICB1bmJpbmQoKTogdm9pZCB7XG4gICAgLy8gRGVzdHJveSBsaXN0ZW5lclxuICAgIHRoaXMuc3ZnU2VsZWN0aW9uPy5pbnRlcnJ1cHQoKS5zZWxlY3RBbGwoJyonKS5pbnRlcnJ1cHQoKTtcbiAgICBpZiAodGhpcy56b29tQmVoYXZpb3IpIHtcbiAgICAgIHRoaXMuem9vbUJlaGF2aW9yLm9uKCdlbmQnLCBudWxsKS5vbignem9vbScsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1ldGhvZHNcbiAgZml0Q2VudGVyKGR1cmF0aW9uOiBudW1iZXIgPSAwKTogdm9pZCB7XG4gICAgdGhpcy5yZVNjYWxlKGR1cmF0aW9uKTtcbiAgfVxuXG4gIGZvY3VzKGlkOiBOelNhZmVBbnksIGR1cmF0aW9uOiBudW1iZXIgPSAwKTogdm9pZCB7XG4gICAgLy8gTWFrZSBzdXJlIHRoaXMgbm9kZSBpcyB1bmRlciBTVkcgY29udGFpbmVyXG4gICAgaWYgKCF0aGlzLnN2Z0VsZW1lbnQuZ2V0RWxlbWVudEJ5SWQoYCR7aWR9YCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0gdGhpcy5zdmdFbGVtZW50LmdldEVsZW1lbnRCeUlkKGAke2lkfWApIGFzIFNWR0dFbGVtZW50O1xuICAgIGNvbnN0IHN2Z1JlY3QgPSB0aGlzLnN2Z0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmdldFJlbGF0aXZlUG9zaXRpb25JbmZvKG5vZGUpO1xuICAgIGNvbnN0IHN2Z1RyYW5zZm9ybSA9IHpvb21UcmFuc2Zvcm0odGhpcy5zdmdFbGVtZW50KTtcblxuICAgIGNvbnN0IGNlbnRlclggPSAocG9zaXRpb24udG9wTGVmdC54ICsgcG9zaXRpb24uYm90dG9tUmlnaHQueCkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAocG9zaXRpb24udG9wTGVmdC55ICsgcG9zaXRpb24uYm90dG9tUmlnaHQueSkgLyAyO1xuICAgIGNvbnN0IGR4ID0gc3ZnUmVjdC5sZWZ0ICsgc3ZnUmVjdC53aWR0aCAvIDIgLSBjZW50ZXJYO1xuICAgIGNvbnN0IGR5ID0gc3ZnUmVjdC50b3AgKyBzdmdSZWN0LmhlaWdodCAvIDIgLSBjZW50ZXJZO1xuXG4gICAgdGhpcy5zdmdTZWxlY3Rpb25cbiAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcbiAgICAgIC5jYWxsKHRoaXMuem9vbUJlaGF2aW9yLnRyYW5zbGF0ZUJ5LCBkeCAvIHN2Z1RyYW5zZm9ybS5rLCBkeSAvIHN2Z1RyYW5zZm9ybS5rKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgem9vbSBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtXG4gICAqL1xuICBwcml2YXRlIHpvb21lZCh7IHRyYW5zZm9ybSB9OiBOelNhZmVBbnkpOiB2b2lkIHtcbiAgICBjb25zdCB7IHgsIHksIGsgfSA9IHRyYW5zZm9ybTtcbiAgICAvLyBVcGRhdGUgZyBlbGVtZW50IHRyYW5zZm9ybVxuICAgICh0aGlzLmdab29tRWxlbWVudCBhcyBTVkdHRWxlbWVudCkuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sICR7eX0pc2NhbGUoJHtrfSlgKTtcbiAgICB0aGlzLm56Wm9vbSA9IGs7XG4gICAgdGhpcy5uelpvb21DaGFuZ2UuZW1pdCh0aGlzLm56Wm9vbSk7XG4gICAgdGhpcy5uelRyYW5zZm9ybUV2ZW50LmVtaXQodHJhbnNmb3JtKTtcbiAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsZSB3aXRoIHpvb20gYW5kIGR1cmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBkdXJhdGlvblxuICAgKiBAcGFyYW0gc2NhbGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcmVTY2FsZShkdXJhdGlvbjogbnVtYmVyLCBzY2FsZT86IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGNhbGN1bGF0ZVRyYW5zZm9ybSh0aGlzLnN2Z0VsZW1lbnQsIHRoaXMuZ1pvb21FbGVtZW50LCBzY2FsZSk7XG4gICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyB4LCB5LCBrIH0gPSB0cmFuc2Zvcm07XG4gICAgY29uc3QgelRyYW5zZm9ybSA9IHpvb21JZGVudGl0eS50cmFuc2xhdGUoeCwgeSkuc2NhbGUoTWF0aC5tYXgoaywgdGhpcy5uek1pblpvb20pKTtcbiAgICB0aGlzLnN2Z1NlbGVjdGlvblxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxuICAgICAgLmNhbGwodGhpcy56b29tQmVoYXZpb3IudHJhbnNmb3JtLCB6VHJhbnNmb3JtKVxuICAgICAgLm9uKCdlbmQuZml0dGVkJywgKCkgPT4ge1xuICAgICAgICB0aGlzLnpvb21CZWhhdmlvci5vbignZW5kLmZpdHRlZCcsIG51bGwpO1xuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGdldFJlbGF0aXZlUG9zaXRpb25JbmZvKG5vZGU6IFNWR0dFbGVtZW50KTogUmVsYXRpdmVQb3NpdGlvbkluZm8ge1xuICAgIGNvbnN0IG5vZGVCb3ggPSBub2RlLmdldEJCb3goKTtcbiAgICBjb25zdCBub2RlQ3RtID0gbm9kZS5nZXRTY3JlZW5DVE0oKTtcbiAgICBsZXQgcG9pbnRUTCA9IHRoaXMuc3ZnRWxlbWVudC5jcmVhdGVTVkdQb2ludCgpO1xuICAgIGxldCBwb2ludEJSID0gdGhpcy5zdmdFbGVtZW50LmNyZWF0ZVNWR1BvaW50KCk7XG5cbiAgICBwb2ludFRMLnggPSBub2RlQm94Lng7XG4gICAgcG9pbnRUTC55ID0gbm9kZUJveC55O1xuICAgIHBvaW50QlIueCA9IG5vZGVCb3gueCArIG5vZGVCb3gud2lkdGg7XG4gICAgcG9pbnRCUi55ID0gbm9kZUJveC55ICsgbm9kZUJveC5oZWlnaHQ7XG4gICAgcG9pbnRUTCA9IHBvaW50VEwubWF0cml4VHJhbnNmb3JtKG5vZGVDdG0hKTtcbiAgICBwb2ludEJSID0gcG9pbnRCUi5tYXRyaXhUcmFuc2Zvcm0obm9kZUN0bSEpO1xuICAgIHJldHVybiB7XG4gICAgICB0b3BMZWZ0OiBwb2ludFRMLFxuICAgICAgYm90dG9tUmlnaHQ6IHBvaW50QlJcbiAgICB9O1xuICB9XG59XG4iXX0=