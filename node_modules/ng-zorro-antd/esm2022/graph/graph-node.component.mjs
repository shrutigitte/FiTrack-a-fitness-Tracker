/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { animate, group, query, style } from '@angular/animations';
import { NgTemplateOutlet } from '@angular/common';
import { booleanAttribute, ChangeDetectionStrategy, Component, Input } from '@angular/core';
import { fromEvent, Subject } from 'rxjs';
import { filter, takeUntil } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/animations";
import * as i2 from "./graph";
export class NzGraphNodeComponent {
    constructor(ngZone, el, builder, renderer2, graphComponent) {
        this.ngZone = ngZone;
        this.el = el;
        this.builder = builder;
        this.renderer2 = renderer2;
        this.graphComponent = graphComponent;
        this.animationInfo = null;
        this.initialState = true;
        this.destroy$ = new Subject();
        this.animationPlayer = null;
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            fromEvent(this.el.nativeElement, 'click')
                .pipe(filter(event => {
                event.preventDefault();
                return this.graphComponent.nzNodeClick.observers.length > 0;
            }), takeUntil(this.destroy$))
                .subscribe(() => {
                // Re-enter the Angular zone and run the change detection only if there're any `nzNodeClick` listeners,
                // e.g.: `<nz-graph (nzNodeClick)="..."></nz-graph>`.
                this.ngZone.run(() => this.graphComponent.nzNodeClick.emit(this.node));
            });
        });
    }
    ngOnDestroy() {
        this.destroy$.next();
    }
    makeAnimation() {
        const cur = this.getAnimationInfo();
        if (this.animationPlayer) {
            this.animationPlayer.destroy();
        }
        let animationFactory;
        const pre = { ...this.animationInfo };
        if (this.initialState) {
            animationFactory = this.builder.build([
                style({ transform: `translate(${cur.x}px, ${cur.y}px)` }),
                query('g', [
                    style({
                        width: `${cur.width}px`,
                        height: `${cur.height}px`
                    })
                ])
            ]);
            this.initialState = false;
        }
        else {
            animationFactory = this.builder.build([
                style({ transform: `translate(${pre.x}px, ${pre.y}px)` }),
                query('g', [
                    style({
                        width: `${pre.width}px`,
                        height: `${pre.height}px`
                    })
                ]),
                group([
                    query('g', [
                        animate('150ms ease-out', style({
                            width: `${cur.width}px`,
                            height: `${cur.height}px`
                        }))
                    ]),
                    animate('150ms ease-out', style({ transform: `translate(${cur.x}px, ${cur.y}px)` }))
                ])
            ]);
        }
        this.animationInfo = cur;
        this.animationPlayer = animationFactory.create(this.el.nativeElement);
        this.animationPlayer.play();
        const done$ = new Subject();
        this.animationPlayer.onDone(() => {
            // Need this for canvas for now.
            this.renderer2.setAttribute(this.el.nativeElement, 'transform', `translate(${cur.x}, ${cur.y})`);
            done$.next();
            done$.complete();
        });
        return done$.asObservable();
    }
    makeNoAnimation() {
        const cur = this.getAnimationInfo();
        // Need this for canvas for now.
        this.renderer2.setAttribute(this.el.nativeElement, 'transform', `translate(${cur.x}, ${cur.y})`);
    }
    getAnimationInfo() {
        const { x, y } = this.nodeTransform();
        return {
            width: this.node.width,
            height: this.node.height,
            x,
            y
        };
    }
    nodeTransform() {
        const x = this.computeCXPositionOfNodeShape() - this.node.width / 2;
        const y = this.node.y - this.node.height / 2;
        return { x, y };
    }
    computeCXPositionOfNodeShape() {
        if (this.node.expanded) {
            return this.node.x;
        }
        return this.node.x - this.node.width / 2 + this.node.coreBox.width / 2;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: NzGraphNodeComponent, deps: [{ token: i0.NgZone }, { token: i0.ElementRef }, { token: i1.AnimationBuilder }, { token: i0.Renderer2 }, { token: i2.NzGraph }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.1.2", type: NzGraphNodeComponent, isStandalone: true, selector: "[nz-graph-node]", inputs: { node: "node", noAnimation: ["noAnimation", "noAnimation", booleanAttribute], customTemplate: "customTemplate" }, host: { properties: { "id": "node.id || node.name", "class.nz-graph-node-expanded": "node.expanded", "class.nz-graph-group-node": "node.type===0", "class.nz-graph-base-node": "node.type===1" } }, ngImport: i0, template: `
    <svg:g>
      @if (customTemplate) {
        <ng-container [ngTemplateOutlet]="customTemplate" [ngTemplateOutletContext]="{ $implicit: node }" />
      } @else {
        <svg:rect class="nz-graph-node-rect" [attr.width]="node.width" [attr.height]="node.height"></svg:rect>
        <svg:text x="10" y="20">{{ node.id || node.name }}</svg:text>
      }
    </svg:g>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: NzGraphNodeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[nz-graph-node]',
                    template: `
    <svg:g>
      @if (customTemplate) {
        <ng-container [ngTemplateOutlet]="customTemplate" [ngTemplateOutletContext]="{ $implicit: node }" />
      } @else {
        <svg:rect class="nz-graph-node-rect" [attr.width]="node.width" [attr.height]="node.height"></svg:rect>
        <svg:text x="10" y="20">{{ node.id || node.name }}</svg:text>
      }
    </svg:g>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        '[id]': 'node.id || node.name',
                        '[class.nz-graph-node-expanded]': 'node.expanded',
                        '[class.nz-graph-group-node]': 'node.type===0',
                        '[class.nz-graph-base-node]': 'node.type===1'
                    },
                    imports: [NgTemplateOutlet],
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i0.ElementRef }, { type: i1.AnimationBuilder }, { type: i0.Renderer2 }, { type: i2.NzGraph }], propDecorators: { node: [{
                type: Input
            }], noAnimation: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], customTemplate: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JhcGgtbm9kZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9jb21wb25lbnRzL2dyYXBoL2dyYXBoLW5vZGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRztBQUVILE9BQU8sRUFBRSxPQUFPLEVBQXVELEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDeEgsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDbkQsT0FBTyxFQUNMLGdCQUFnQixFQUNoQix1QkFBdUIsRUFDdkIsU0FBUyxFQUVULEtBQUssRUFNTixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsU0FBUyxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0RCxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7O0FBaUNuRCxNQUFNLE9BQU8sb0JBQW9CO0lBYS9CLFlBQ1UsTUFBYyxFQUNkLEVBQTJCLEVBQzNCLE9BQXlCLEVBQ3pCLFNBQW9CLEVBQ3BCLGNBQXVCO1FBSnZCLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDZCxPQUFFLEdBQUYsRUFBRSxDQUF5QjtRQUMzQixZQUFPLEdBQVAsT0FBTyxDQUFrQjtRQUN6QixjQUFTLEdBQVQsU0FBUyxDQUFXO1FBQ3BCLG1CQUFjLEdBQWQsY0FBYyxDQUFTO1FBWGpDLGtCQUFhLEdBQWdCLElBQUksQ0FBQztRQUNsQyxpQkFBWSxHQUFHLElBQUksQ0FBQztRQUVaLGFBQVEsR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDO1FBQy9CLG9CQUFlLEdBQTJCLElBQUksQ0FBQztJQVFwRCxDQUFDO0lBRUosUUFBUTtRQUNOLElBQUksQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsR0FBRyxFQUFFO1lBQ2pDLFNBQVMsQ0FBYSxJQUFJLENBQUMsRUFBRSxD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S0FBSzt1QkFBQyxFQUFFLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRTtnQkFDN0IsY0FBYztzQkFBdEIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9naXRodWIuY29tL05HLVpPUlJPL25nLXpvcnJvLWFudGQvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbmltcG9ydCB7IGFuaW1hdGUsIEFuaW1hdGlvbkJ1aWxkZXIsIEFuaW1hdGlvbkZhY3RvcnksIEFuaW1hdGlvblBsYXllciwgZ3JvdXAsIHF1ZXJ5LCBzdHlsZSB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgTmdUZW1wbGF0ZU91dGxldCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBib29sZWFuQXR0cmlidXRlLFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBJbnB1dCxcbiAgTmdab25lLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgUmVuZGVyZXIyLFxuICBUZW1wbGF0ZVJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCwgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IE56R3JhcGggfSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7IE56R3JhcGhHcm91cE5vZGUsIE56R3JhcGhOb2RlIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuXG5pbnRlcmZhY2UgSW5mbyB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbn1cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ1tuei1ncmFwaC1ub2RlXScsXG4gIHRlbXBsYXRlOiBgXG4gICAgPHN2ZzpnPlxuICAgICAgQGlmIChjdXN0b21UZW1wbGF0ZSkge1xuICAgICAgICA8bmctY29udGFpbmVyIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImN1c3RvbVRlbXBsYXRlXCIgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgJGltcGxpY2l0OiBub2RlIH1cIiAvPlxuICAgICAgfSBAZWxzZSB7XG4gICAgICAgIDxzdmc6cmVjdCBjbGFzcz1cIm56LWdyYXBoLW5vZGUtcmVjdFwiIFthdHRyLndpZHRoXT1cIm5vZGUud2lkdGhcIiBbYXR0ci5oZWlnaHRdPVwibm9kZS5oZWlnaHRcIj48L3N2ZzpyZWN0PlxuICAgICAgICA8c3ZnOnRleHQgeD1cIjEwXCIgeT1cIjIwXCI+e3sgbm9kZS5pZCB8fCBub2RlLm5hbWUgfX08L3N2Zzp0ZXh0PlxuICAgICAgfVxuICAgIDwvc3ZnOmc+XG4gIGAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBob3N0OiB7XG4gICAgJ1tpZF0nOiAnbm9kZS5pZCB8fCBub2RlLm5hbWUnLFxuICAgICdbY2xhc3MubnotZ3JhcGgtbm9kZS1leHBhbmRlZF0nOiAnbm9kZS5leHBhbmRlZCcsXG4gICAgJ1tjbGFzcy5uei1ncmFwaC1ncm91cC1ub2RlXSc6ICdub2RlLnR5cGU9PT0wJyxcbiAgICAnW2NsYXNzLm56LWdyYXBoLWJhc2Utbm9kZV0nOiAnbm9kZS50eXBlPT09MSdcbiAgfSxcbiAgaW1wb3J0czogW05nVGVtcGxhdGVPdXRsZXRdLFxuICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIE56R3JhcGhOb2RlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBASW5wdXQoKSBub2RlITogTnpHcmFwaE5vZGUgfCBOekdyYXBoR3JvdXBOb2RlO1xuICBASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSkgbm9BbmltYXRpb24/OiBib29sZWFuO1xuICBASW5wdXQoKSBjdXN0b21UZW1wbGF0ZT86IFRlbXBsYXRlUmVmPHtcbiAgICAkaW1wbGljaXQ6IE56R3JhcGhOb2RlIHwgTnpHcmFwaEdyb3VwTm9kZTtcbiAgfT47XG5cbiAgYW5pbWF0aW9uSW5mbzogSW5mbyB8IG51bGwgPSBudWxsO1xuICBpbml0aWFsU3RhdGUgPSB0cnVlO1xuXG4gIHByaXZhdGUgZGVzdHJveSQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICBwcml2YXRlIGFuaW1hdGlvblBsYXllcjogQW5pbWF0aW9uUGxheWVyIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSxcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICBwcml2YXRlIGJ1aWxkZXI6IEFuaW1hdGlvbkJ1aWxkZXIsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIGdyYXBoQ29tcG9uZW50OiBOekdyYXBoXG4gICkge31cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICBmcm9tRXZlbnQ8TW91c2VFdmVudD4odGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnY2xpY2snKVxuICAgICAgICAucGlwZShcbiAgICAgICAgICBmaWx0ZXIoZXZlbnQgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyYXBoQ29tcG9uZW50Lm56Tm9kZUNsaWNrLm9ic2VydmVycy5sZW5ndGggPiAwO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKVxuICAgICAgICApXG4gICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgIC8vIFJlLWVudGVyIHRoZSBBbmd1bGFyIHpvbmUgYW5kIHJ1biB0aGUgY2hhbmdlIGRldGVjdGlvbiBvbmx5IGlmIHRoZXJlJ3JlIGFueSBgbnpOb2RlQ2xpY2tgIGxpc3RlbmVycyxcbiAgICAgICAgICAvLyBlLmcuOiBgPG56LWdyYXBoIChuek5vZGVDbGljayk9XCIuLi5cIj48L256LWdyYXBoPmAuXG4gICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHRoaXMuZ3JhcGhDb21wb25lbnQubnpOb2RlQ2xpY2suZW1pdCh0aGlzLm5vZGUpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgfVxuXG4gIG1ha2VBbmltYXRpb24oKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgY29uc3QgY3VyID0gdGhpcy5nZXRBbmltYXRpb25JbmZvKCk7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uUGxheWVyKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblBsYXllci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGxldCBhbmltYXRpb25GYWN0b3J5OiBBbmltYXRpb25GYWN0b3J5O1xuICAgIGNvbnN0IHByZSA9IHsgLi4udGhpcy5hbmltYXRpb25JbmZvIH0gYXMgSW5mbztcblxuICAgIGlmICh0aGlzLmluaXRpYWxTdGF0ZSkge1xuICAgICAgYW5pbWF0aW9uRmFjdG9yeSA9IHRoaXMuYnVpbGRlci5idWlsZChbXG4gICAgICAgIHN0eWxlKHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7Y3VyLnh9cHgsICR7Y3VyLnl9cHgpYCB9KSxcbiAgICAgICAgcXVlcnkoJ2cnLCBbXG4gICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgd2lkdGg6IGAke2N1ci53aWR0aH1weGAsXG4gICAgICAgICAgICBoZWlnaHQ6IGAke2N1ci5oZWlnaHR9cHhgXG4gICAgICAgICAgfSlcbiAgICAgICAgXSlcbiAgICAgIF0pO1xuICAgICAgdGhpcy5pbml0aWFsU3RhdGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5pbWF0aW9uRmFjdG9yeSA9IHRoaXMuYnVpbGRlci5idWlsZChbXG4gICAgICAgIHN0eWxlKHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7cHJlIS54fXB4LCAke3ByZSEueX1weClgIH0pLFxuICAgICAgICBxdWVyeSgnZycsIFtcbiAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICB3aWR0aDogYCR7cHJlIS53aWR0aH1weGAsXG4gICAgICAgICAgICBoZWlnaHQ6IGAke3ByZSEuaGVpZ2h0fXB4YFxuICAgICAgICAgIH0pXG4gICAgICAgIF0pLFxuICAgICAgICBncm91cChbXG4gICAgICAgICAgcXVlcnkoJ2cnLCBbXG4gICAgICAgICAgICBhbmltYXRlKFxuICAgICAgICAgICAgICAnMTUwbXMgZWFzZS1vdXQnLFxuICAgICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGAke2N1ci53aWR0aH1weGAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBgJHtjdXIuaGVpZ2h0fXB4YFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIGFuaW1hdGUoJzE1MG1zIGVhc2Utb3V0Jywgc3R5bGUoeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtjdXIueH1weCwgJHtjdXIueX1weClgIH0pKVxuICAgICAgICBdKVxuICAgICAgXSk7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uSW5mbyA9IGN1cjtcbiAgICB0aGlzLmFuaW1hdGlvblBsYXllciA9IGFuaW1hdGlvbkZhY3RvcnkuY3JlYXRlKHRoaXMuZWwubmF0aXZlRWxlbWVudCk7XG4gICAgdGhpcy5hbmltYXRpb25QbGF5ZXIucGxheSgpO1xuICAgIGNvbnN0IGRvbmUkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICB0aGlzLmFuaW1hdGlvblBsYXllci5vbkRvbmUoKCkgPT4ge1xuICAgICAgLy8gTmVlZCB0aGlzIGZvciBjYW52YXMgZm9yIG5vdy5cbiAgICAgIHRoaXMucmVuZGVyZXIyLnNldEF0dHJpYnV0ZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7Y3VyLnh9LCAke2N1ci55fSlgKTtcbiAgICAgIGRvbmUkLm5leHQoKTtcbiAgICAgIGRvbmUkLmNvbXBsZXRlKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRvbmUkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgbWFrZU5vQW5pbWF0aW9uKCk6IHZvaWQge1xuICAgIGNvbnN0IGN1ciA9IHRoaXMuZ2V0QW5pbWF0aW9uSW5mbygpO1xuICAgIC8vIE5lZWQgdGhpcyBmb3IgY2FudmFzIGZvciBub3cuXG4gICAgdGhpcy5yZW5kZXJlcjIuc2V0QXR0cmlidXRlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtjdXIueH0sICR7Y3VyLnl9KWApO1xuICB9XG5cbiAgZ2V0QW5pbWF0aW9uSW5mbygpOiBJbmZvIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMubm9kZVRyYW5zZm9ybSgpO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGhpcy5ub2RlLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLm5vZGUuaGVpZ2h0LFxuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG5cbiAgbm9kZVRyYW5zZm9ybSgpOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0ge1xuICAgIGNvbnN0IHggPSB0aGlzLmNvbXB1dGVDWFBvc2l0aW9uT2ZOb2RlU2hhcGUoKSAtIHRoaXMubm9kZS53aWR0aCAvIDI7XG4gICAgY29uc3QgeSA9IHRoaXMubm9kZS55IC0gdGhpcy5ub2RlLmhlaWdodCAvIDI7XG4gICAgcmV0dXJuIHsgeCwgeSB9O1xuICB9XG5cbiAgY29tcHV0ZUNYUG9zaXRpb25PZk5vZGVTaGFwZSgpOiBudW1iZXIge1xuICAgIGlmICgodGhpcy5ub2RlIGFzIE56R3JhcGhHcm91cE5vZGUpLmV4cGFuZGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlLng7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5vZGUueCAtIHRoaXMubm9kZS53aWR0aCAvIDIgKyB0aGlzLm5vZGUuY29yZUJveC53aWR0aCAvIDI7XG4gIH1cbn1cbiJdfQ==