/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { NgIf, NgTemplateOutlet } from '@angular/common';
import { Component, EventEmitter, Input, Output, booleanAttribute } from '@angular/core';
import { PickerComponent } from './components/picker.component';
import { SliderComponent } from './components/slider.component';
import { NgAntdColorBlockComponent } from './ng-antd-color-block.component';
import { defaultColor, generateColor } from './util/util';
import * as i0 from "@angular/core";
export class NgAntdColorPickerComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.nzOnChange = new EventEmitter();
        this.nzOnChangeComplete = new EventEmitter();
        this.panelRenderHeader = null;
        this.panelRenderFooter = null;
        this.disabledAlpha = false;
        this.disabled = false;
        this.colorValue = null;
        this.alphaColor = '';
        this.hueColor = [
            'rgb(255, 0, 0) 0%',
            'rgb(255, 255, 0) 17%',
            'rgb(0, 255, 0) 33%',
            'rgb(0, 255, 255) 50%',
            'rgb(0, 0, 255) 67%',
            'rgb(255, 0, 255) 83%',
            'rgb(255, 0, 0) 100%'
        ];
        this.gradientColors = ['rgba(255, 0, 4, 0) 0%', this.alphaColor];
        this.toRgbString = this.colorValue?.toRgbString() || '';
    }
    ngOnInit() {
        this.setColorValue(this.value);
    }
    ngOnChanges(changes) {
        const { value, defaultValue } = changes;
        if (value || defaultValue) {
            this.setColorValue(this.value);
        }
    }
    hasValue(value) {
        return !!value;
    }
    setColorValue(color) {
        let mergeState;
        if (this.hasValue(color)) {
            mergeState = color;
        }
        else if (this.hasValue(this.defaultValue)) {
            mergeState = this.defaultValue;
        }
        else {
            mergeState = defaultColor;
        }
        this.colorValue = generateColor(mergeState);
        this.setAlphaColor(this.colorValue);
        this.toRgbString = this.colorValue?.toRgbString() || '';
        this.cdr.detectChanges();
    }
    setAlphaColor(colorValue) {
        const rgb = generateColor(colorValue.toRgbString());
        this.alphaColor = rgb.toRgbString();
        this.gradientColors = ['rgba(255, 0, 4, 0) 0%', this.alphaColor];
        this.cdr.markForCheck();
    }
    handleChange(color, type) {
        this.setColorValue(color);
        this.nzOnChange.emit({ color, type });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: NgAntdColorPickerComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "18.1.2", type: NgAntdColorPickerComponent, isStandalone: true, selector: "ng-antd-color-picker", inputs: { value: "value", defaultValue: "defaultValue", panelRenderHeader: "panelRenderHeader", panelRenderFooter: "panelRenderFooter", disabledAlpha: ["disabledAlpha", "disabledAlpha", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute] }, outputs: { nzOnChange: "nzOnChange", nzOnChangeComplete: "nzOnChangeComplete" }, usesOnChanges: true, ngImport: i0, template: `
    <div class="ant-color-picker-panel" [class.ant-color-picker-panel-disabled]="disabled">
      <ng-container *ngIf="panelRenderHeader">
        <ng-template [ngTemplateOutlet]="panelRenderHeader"></ng-template>
      </ng-container>
      <color-picker
        [color]="colorValue"
        (nzOnChange)="handleChange($event)"
        [disabled]="disabled"
        (nzOnChangeComplete)="nzOnChangeComplete.emit($event)"
      ></color-picker>
      <div class="ant-color-picker-slider-container">
        <div class="ant-color-picker-slider-group" [class.ant-color-picker-slider-group-disabled-alpha]="disabledAlpha">
          <color-slider
            [color]="colorValue"
            [value]="'hsl(' + colorValue?.toHsb()?.h + ',100%, 50%)'"
            [gradientColors]="hueColor"
            (nzOnChange)="handleChange($event, 'hue')"
            [disabled]="disabled"
            (nzOnChangeComplete)="nzOnChangeComplete.emit($event)"
          ></color-slider>
          <ng-container *ngIf="!disabledAlpha">
            <color-slider
              type="alpha"
              [color]="colorValue"
              [value]="toRgbString"
              [gradientColors]="gradientColors"
              (nzOnChange)="handleChange($event, 'alpha')"
              [disabled]="disabled"
              (nzOnChangeComplete)="nzOnChangeComplete.emit($event)"
            ></color-slider>
          </ng-container>
        </div>
        <ng-antd-color-block [color]="toRgbString"></ng-antd-color-block>
      </div>
      <ng-container *ngIf="panelRenderFooter">
        <ng-template [ngTemplateOutlet]="panelRenderFooter"></ng-template>
      </ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: PickerComponent, selector: "color-picker", inputs: ["color", "disabled"], outputs: ["nzOnChange", "nzOnChangeComplete"] }, { kind: "component", type: SliderComponent, selector: "color-slider", inputs: ["gradientColors", "direction", "type", "color", "value", "disabled"], outputs: ["nzOnChange", "nzOnChangeComplete"] }, { kind: "component", type: NgAntdColorBlockComponent, selector: "ng-antd-color-block", inputs: ["color"], outputs: ["nzOnClick"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: NgAntdColorPickerComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'ng-antd-color-picker',
                    standalone: true,
                    imports: [NgIf, PickerComponent, SliderComponent, NgAntdColorBlockComponent, NgTemplateOutlet],
                    template: `
    <div class="ant-color-picker-panel" [class.ant-color-picker-panel-disabled]="disabled">
      <ng-container *ngIf="panelRenderHeader">
        <ng-template [ngTemplateOutlet]="panelRenderHeader"></ng-template>
      </ng-container>
      <color-picker
        [color]="colorValue"
        (nzOnChange)="handleChange($event)"
        [disabled]="disabled"
        (nzOnChangeComplete)="nzOnChangeComplete.emit($event)"
      ></color-picker>
      <div class="ant-color-picker-slider-container">
        <div class="ant-color-picker-slider-group" [class.ant-color-picker-slider-group-disabled-alpha]="disabledAlpha">
          <color-slider
            [color]="colorValue"
            [value]="'hsl(' + colorValue?.toHsb()?.h + ',100%, 50%)'"
            [gradientColors]="hueColor"
            (nzOnChange)="handleChange($event, 'hue')"
            [disabled]="disabled"
            (nzOnChangeComplete)="nzOnChangeComplete.emit($event)"
          ></color-slider>
          <ng-container *ngIf="!disabledAlpha">
            <color-slider
              type="alpha"
              [color]="colorValue"
              [value]="toRgbString"
              [gradientColors]="gradientColors"
              (nzOnChange)="handleChange($event, 'alpha')"
              [disabled]="disabled"
              (nzOnChangeComplete)="nzOnChangeComplete.emit($event)"
            ></color-slider>
          </ng-container>
        </div>
        <ng-antd-color-block [color]="toRgbString"></ng-antd-color-block>
      </div>
      <ng-container *ngIf="panelRenderFooter">
        <ng-template [ngTemplateOutlet]="panelRenderFooter"></ng-template>
      </ng-container>
    </div>
  `
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }], propDecorators: { value: [{
                type: Input
            }], defaultValue: [{
                type: Input
            }], nzOnChange: [{
                type: Output
            }], nzOnChangeComplete: [{
                type: Output
            }], panelRenderHeader: [{
                type: Input
            }], panelRenderFooter: [{
                type: Input
            }], disabledAlpha: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctYW50ZC1jb2xvci1waWNrZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29tcG9uZW50cy9jb2xvci1waWNrZXIvc3JjL25nLWFudGQtY29sb3ItcGlja2VyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7QUFFSCxPQUFPLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekQsT0FBTyxFQUVMLFNBQVMsRUFDVCxZQUFZLEVBQ1osS0FBSyxFQUdMLE1BQU0sRUFHTixnQkFBZ0IsRUFDakIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUdoRSxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUM1RSxPQUFPLEVBQUUsWUFBWSxFQUFFLGFBQWEsRUFBRSxNQUFNLGFBQWEsQ0FBQzs7QUFnRDFELE1BQU0sT0FBTywwQkFBMEI7SUEyQnJDLFlBQW9CLEdBQXNCO1FBQXRCLFFBQUcsR0FBSCxHQUFHLENBQW1CO1FBeEJ2QixlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQTBDLENBQUM7UUFDeEUsdUJBQWtCLEdBQUcsSUFBSSxZQUFZLEVBQWlCLENBQUM7UUFDakUsc0JBQWlCLEdBQTZCLElBQUksQ0FBQztRQUNuRCxzQkFBaUIsR0FBNkIsSUFBSSxDQUFDO1FBQ3BCLGtCQUFhLEdBQVksS0FBSyxDQUFDO1FBQy9CLGFBQVEsR0FBWSxLQUFLLENBQUM7UUFFbEUsZUFBVSxHQUFpQixJQUFJLENBQUM7UUFDaEMsZUFBVSxHQUFXLEVBQUUsQ0FBQztRQUV4QixhQUFRLEdBQWE7WUFDbkIsbUJBQW1CO1lBQ25CLHNCQUFzQjtZQUN0QixvQkFBb0I7WUFDcEIsc0JBQXNCO1lBQ3RC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Q1Q7aUJBQ0Y7c0ZBRVUsS0FBSztzQkFBYixLQUFLO2dCQUNHLFlBQVk7c0JBQXBCLEtBQUs7Z0JBQ2EsVUFBVTtzQkFBNUIsTUFBTTtnQkFDWSxrQkFBa0I7c0JBQXBDLE1BQU07Z0JBQ0UsaUJBQWlCO3NCQUF6QixLQUFLO2dCQUNHLGlCQUFpQjtzQkFBekIsS0FBSztnQkFDa0MsYUFBYTtzQkFBcEQsS0FBSzt1QkFBQyxFQUFFLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRTtnQkFDRSxRQUFRO3NCQUEvQyxLQUFLO3VCQUFDLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2dpdGh1Yi5jb20vTkctWk9SUk8vbmctem9ycm8tYW50ZC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuaW1wb3J0IHsgTmdJZiwgTmdUZW1wbGF0ZU91dGxldCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBTaW1wbGVDaGFuZ2VzLFxuICBUZW1wbGF0ZVJlZixcbiAgYm9vbGVhbkF0dHJpYnV0ZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgUGlja2VyQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3BpY2tlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2xpZGVyQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3NsaWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuL2ludGVyZmFjZXMvY29sb3InO1xuaW1wb3J0IHsgQ29sb3JHZW5JbnB1dCwgQ29sb3JWYWx1ZSwgSHNiYUNvbG9yVHlwZSB9IGZyb20gJy4vaW50ZXJmYWNlcy90eXBlJztcbmltcG9ydCB7IE5nQW50ZENvbG9yQmxvY2tDb21wb25lbnQgfSBmcm9tICcuL25nLWFudGQtY29sb3ItYmxvY2suY29tcG9uZW50JztcbmltcG9ydCB7IGRlZmF1bHRDb2xvciwgZ2VuZXJhdGVDb2xvciB9IGZyb20gJy4vdXRpbC91dGlsJztcblxuQENvbXBvbmVudCh7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvY29tcG9uZW50LXNlbGVjdG9yXG4gIHNlbGVjdG9yOiAnbmctYW50ZC1jb2xvci1waWNrZXInLFxuICBzdGFuZGFsb25lOiB0cnVlLFxuICBpbXBvcnRzOiBbTmdJZiwgUGlja2VyQ29tcG9uZW50LCBTbGlkZXJDb21wb25lbnQsIE5nQW50ZENvbG9yQmxvY2tDb21wb25lbnQsIE5nVGVtcGxhdGVPdXRsZXRdLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJhbnQtY29sb3ItcGlja2VyLXBhbmVsXCIgW2NsYXNzLmFudC1jb2xvci1waWNrZXItcGFuZWwtZGlzYWJsZWRdPVwiZGlzYWJsZWRcIj5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJwYW5lbFJlbmRlckhlYWRlclwiPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwicGFuZWxSZW5kZXJIZWFkZXJcIj48L25nLXRlbXBsYXRlPlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICA8Y29sb3ItcGlja2VyXG4gICAgICAgIFtjb2xvcl09XCJjb2xvclZhbHVlXCJcbiAgICAgICAgKG56T25DaGFuZ2UpPVwiaGFuZGxlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAobnpPbkNoYW5nZUNvbXBsZXRlKT1cIm56T25DaGFuZ2VDb21wbGV0ZS5lbWl0KCRldmVudClcIlxuICAgICAgPjwvY29sb3ItcGlja2VyPlxuICAgICAgPGRpdiBjbGFzcz1cImFudC1jb2xvci1waWNrZXItc2xpZGVyLWNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYW50LWNvbG9yLXBpY2tlci1zbGlkZXItZ3JvdXBcIiBbY2xhc3MuYW50LWNvbG9yLXBpY2tlci1zbGlkZXItZ3JvdXAtZGlzYWJsZWQtYWxwaGFdPVwiZGlzYWJsZWRBbHBoYVwiPlxuICAgICAgICAgIDxjb2xvci1zbGlkZXJcbiAgICAgICAgICAgIFtjb2xvcl09XCJjb2xvclZhbHVlXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCInaHNsKCcgKyBjb2xvclZhbHVlPy50b0hzYigpPy5oICsgJywxMDAlLCA1MCUpJ1wiXG4gICAgICAgICAgICBbZ3JhZGllbnRDb2xvcnNdPVwiaHVlQ29sb3JcIlxuICAgICAgICAgICAgKG56T25DaGFuZ2UpPVwiaGFuZGxlQ2hhbmdlKCRldmVudCwgJ2h1ZScpXCJcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAobnpPbkNoYW5nZUNvbXBsZXRlKT1cIm56T25DaGFuZ2VDb21wbGV0ZS5lbWl0KCRldmVudClcIlxuICAgICAgICAgID48L2NvbG9yLXNsaWRlcj5cbiAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIWRpc2FibGVkQWxwaGFcIj5cbiAgICAgICAgICAgIDxjb2xvci1zbGlkZXJcbiAgICAgICAgICAgICAgdHlwZT1cImFscGhhXCJcbiAgICAgICAgICAgICAgW2NvbG9yXT1cImNvbG9yVmFsdWVcIlxuICAgICAgICAgICAgICBbdmFsdWVdPVwidG9SZ2JTdHJpbmdcIlxuICAgICAgICAgICAgICBbZ3JhZGllbnRDb2xvcnNdPVwiZ3JhZGllbnRDb2xvcnNcIlxuICAgICAgICAgICAgICAobnpPbkNoYW5nZSk9XCJoYW5kbGVDaGFuZ2UoJGV2ZW50LCAnYWxwaGEnKVwiXG4gICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgIChuek9uQ2hhbmdlQ29tcGxldGUpPVwibnpPbkNoYW5nZUNvbXBsZXRlLmVtaXQoJGV2ZW50KVwiXG4gICAgICAgICAgICA+PC9jb2xvci1zbGlkZXI+XG4gICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8bmctYW50ZC1jb2xvci1ibG9jayBbY29sb3JdPVwidG9SZ2JTdHJpbmdcIj48L25nLWFudGQtY29sb3ItYmxvY2s+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJwYW5lbFJlbmRlckZvb3RlclwiPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwicGFuZWxSZW5kZXJGb290ZXJcIj48L25nLXRlbXBsYXRlPlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG4gIGBcbn0pXG5leHBvcnQgY2xhc3MgTmdBbnRkQ29sb3JQaWNrZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIHZhbHVlOiBDb2xvclZhbHVlO1xuICBASW5wdXQoKSBkZWZhdWx0VmFsdWU6IENvbG9yVmFsdWU7XG4gIEBPdXRwdXQoKSByZWFkb25seSBuek9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjx7IGNvbG9yOiBDb2xvcjsgdHlwZT86IEhzYmFDb2xvclR5cGUgfT4oKTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IG56T25DaGFuZ2VDb21wbGV0ZSA9IG5ldyBFdmVudEVtaXR0ZXI8SHNiYUNvbG9yVHlwZT4oKTtcbiAgQElucHV0KCkgcGFuZWxSZW5kZXJIZWFkZXI6IFRlbXBsYXRlUmVmPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG4gIEBJbnB1dCgpIHBhbmVsUmVuZGVyRm9vdGVyOiBUZW1wbGF0ZVJlZjx2b2lkPiB8IG51bGwgPSBudWxsO1xuICBASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSkgZGlzYWJsZWRBbHBoYTogYm9vbGVhbiA9IGZhbHNlO1xuICBASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSkgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb2xvclZhbHVlOiBDb2xvciB8IG51bGwgPSBudWxsO1xuICBhbHBoYUNvbG9yOiBzdHJpbmcgPSAnJztcblxuICBodWVDb2xvcjogc3RyaW5nW10gPSBbXG4gICAgJ3JnYigyNTUsIDAsIDApIDAlJyxcbiAgICAncmdiKDI1NSwgMjU1LCAwKSAxNyUnLFxuICAgICdyZ2IoMCwgMjU1LCAwKSAzMyUnLFxuICAgICdyZ2IoMCwgMjU1LCAyNTUpIDUwJScsXG4gICAgJ3JnYigwLCAwLCAyNTUpIDY3JScsXG4gICAgJ3JnYigyNTUsIDAsIDI1NSkgODMlJyxcbiAgICAncmdiKDI1NSwgMCwgMCkgMTAwJSdcbiAgXTtcblxuICBncmFkaWVudENvbG9yczogc3RyaW5nW10gPSBbJ3JnYmEoMjU1LCAwLCA0LCAwKSAwJScsIHRoaXMuYWxwaGFDb2xvcl07XG5cbiAgdG9SZ2JTdHJpbmc6IHN0cmluZyA9IHRoaXMuY29sb3JWYWx1ZT8udG9SZ2JTdHJpbmcoKSB8fCAnJztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHt9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5zZXRDb2xvclZhbHVlKHRoaXMudmFsdWUpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGNvbnN0IHsgdmFsdWUsIGRlZmF1bHRWYWx1ZSB9ID0gY2hhbmdlcztcbiAgICBpZiAodmFsdWUgfHwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB0aGlzLnNldENvbG9yVmFsdWUodGhpcy52YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgaGFzVmFsdWUodmFsdWU6IENvbG9yVmFsdWUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF2YWx1ZTtcbiAgfVxuXG4gIHNldENvbG9yVmFsdWUoY29sb3I6IENvbG9yVmFsdWUpOiB2b2lkIHtcbiAgICBsZXQgbWVyZ2VTdGF0ZTtcbiAgICBpZiAodGhpcy5oYXNWYWx1ZShjb2xvcikpIHtcbiAgICAgIG1lcmdlU3RhdGUgPSBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGFzVmFsdWUodGhpcy5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICBtZXJnZVN0YXRlID0gdGhpcy5kZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlU3RhdGUgPSBkZWZhdWx0Q29sb3I7XG4gICAgfVxuICAgIHRoaXMuY29sb3JWYWx1ZSA9IGdlbmVyYXRlQ29sb3IobWVyZ2VTdGF0ZSBhcyBDb2xvckdlbklucHV0KTtcbiAgICB0aGlzLnNldEFscGhhQ29sb3IodGhpcy5jb2xvclZhbHVlKTtcbiAgICB0aGlzLnRvUmdiU3RyaW5nID0gdGhpcy5jb2xvclZhbHVlPy50b1JnYlN0cmluZygpIHx8ICcnO1xuICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgfVxuXG4gIHNldEFscGhhQ29sb3IoY29sb3JWYWx1ZTogQ29sb3IpOiB2b2lkIHtcbiAgICBjb25zdCByZ2IgPSBnZW5lcmF0ZUNvbG9yKGNvbG9yVmFsdWUudG9SZ2JTdHJpbmcoKSk7XG4gICAgdGhpcy5hbHBoYUNvbG9yID0gcmdiLnRvUmdiU3RyaW5nKCk7XG4gICAgdGhpcy5ncmFkaWVudENvbG9ycyA9IFsncmdiYSgyNTUsIDAsIDQsIDApIDAlJywgdGhpcy5hbHBoYUNvbG9yXTtcbiAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIGhhbmRsZUNoYW5nZShjb2xvcjogQ29sb3IsIHR5cGU/OiBIc2JhQ29sb3JUeXBlKTogdm9pZCB7XG4gICAgdGhpcy5zZXRDb2xvclZhbHVlKGNvbG9yKTtcbiAgICB0aGlzLm56T25DaGFuZ2UuZW1pdCh7IGNvbG9yLCB0eXBlIH0pO1xuICB9XG59XG4iXX0=