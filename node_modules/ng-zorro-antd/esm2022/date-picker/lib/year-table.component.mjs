/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, Component, ViewEncapsulation } from '@angular/core';
import { valueFunctionProp } from 'ng-zorro-antd/core/util';
import { AbstractTable } from './abstract-table';
import { NgClass, NgForOf, NgIf, NgSwitch, NgSwitchCase, NgSwitchDefault, NgTemplateOutlet } from '@angular/common';
import * as i0 from "@angular/core";
import * as i1 from "ng-zorro-antd/i18n";
export class YearTableComponent extends AbstractTable {
    constructor(dateHelper) {
        super();
        this.dateHelper = dateHelper;
        this.MAX_ROW = 4;
        this.MAX_COL = 3;
    }
    makeHeadRow() {
        return [];
    }
    makeBodyRows() {
        const currentYear = this.activeDate && this.activeDate.getYear();
        const startYear = parseInt(`${currentYear / 10}`, 10) * 10;
        const endYear = startYear + 9;
        const previousYear = startYear - 1;
        const years = [];
        let yearValue = 0;
        for (let rowIndex = 0; rowIndex < this.MAX_ROW; rowIndex++) {
            const row = {
                dateCells: [],
                trackByIndex: rowIndex
            };
            for (let colIndex = 0; colIndex < this.MAX_COL; colIndex++) {
                const yearNum = previousYear + yearValue;
                const year = this.activeDate.setYear(yearNum);
                const content = this.dateHelper.format(year.nativeDate, 'yyyy');
                const isDisabled = this.isDisabledYear(year);
                const cell = {
                    trackByIndex: colIndex,
                    value: year.nativeDate,
                    isDisabled,
                    isSameDecade: yearNum >= startYear && yearNum <= endYear,
                    isSelected: yearNum === (this.value && this.value.getYear()),
                    content,
                    title: content,
                    classMap: {},
                    isLastCellInPanel: year.getYear() === endYear,
                    isFirstCellInPanel: year.getYear() === startYear,
                    cellRender: valueFunctionProp(this.cellRender, year), // Customized content
                    fullCellRender: valueFunctionProp(this.fullCellRender, year),
                    onClick: () => this.chooseYear(cell.value.getFullYear()), // don't use yearValue here,
                    onMouseEnter: () => this.cellHover.emit(year)
                };
                this.addCellProperty(cell, year);
                row.dateCells.push(cell);
                yearValue++;
            }
            years.push(row);
        }
        return years;
    }
    getClassMap(cell) {
        return {
            ...super.getClassMap(cell),
            [`ant-picker-cell-in-view`]: !!cell.isSameDecade
        };
    }
    isDisabledYear(year) {
        if (!this.disabledDate) {
            return false;
        }
        const firstOfMonth = year.setMonth(0).setDate(1);
        for (let date = firstOfMonth; date.getYear() === year.getYear(); date = date.addDays(1)) {
            if (!this.disabledDate(date.nativeDate)) {
                return false;
            }
        }
        return true;
    }
    addCellProperty(cell, year) {
        if (this.hasRangeValue()) {
            const [startHover, endHover] = this.hoverValue;
            const [startSelected, endSelected] = this.selectedValue;
            // Selected
            if (startSelected?.isSameYear(year)) {
                cell.isSelectedStart = true;
                cell.isSelected = true;
            }
            if (endSelected?.isSameYear(year)) {
                cell.isSelectedEnd = true;
                cell.isSelected = true;
            }
            if (startHover && endHover) {
                cell.isHoverStart = startHover.isSameYear(year);
                cell.isHoverEnd = endHover.isSameYear(year);
                cell.isInHoverRange = startHover.isBeforeYear(year) && year.isBeforeYear(endHover);
            }
            cell.isStartSingle = startSelected && !endSelected;
            cell.isEndSingle = !startSelected && endSelected;
            cell.isInSelectedRange = startSelected?.isBeforeYear(year) && year?.isBeforeYear(endSelected);
            cell.isRangeStartNearHover = startSelected && cell.isInHoverRange;
            cell.isRangeEndNearHover = endSelected && cell.isInHoverRange;
        }
        else if (year.isSameYear(this.value)) {
            cell.isSelected = true;
        }
        cell.classMap = this.getClassMap(cell);
    }
    chooseYear(year) {
        this.value = this.activeDate.setYear(year);
        this.valueChange.emit(this.value);
        this.render();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: YearTableComponent, deps: [{ token: i1.DateHelperService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.1.2", type: YearTableComponent, isStandalone: true, selector: "year-table", exportAs: ["yearTable"], usesInheritance: true, ngImport: i0, template: "<table class=\"ant-picker-content\" cellspacing=\"0\" role=\"grid\">\n  @if(headRow && headRow.length > 0) {\n    <thead>\n      <tr role=\"row\">\n        @if(showWeek) {\n          <th role=\"columnheader\"></th>\n        }\n        @for(cell of headRow; track cell) {\n          <th role=\"columnheader\" title=\"{{ cell.title }}\"> {{ cell.content }} </th>\n        }\n      </tr>\n    </thead>\n  }\n\n  <tbody>\n    @for(row of bodyRows; track row.trackByIndex) {\n      <tr [ngClass]=\"row.classMap!\" role=\"row\">\n        @if(row.weekNum) {\n          <td role=\"gridcell\" class=\"{{ prefixCls }}-cell-week\"> {{ row.weekNum }} </td>\n        }\n        @for(cell of row.dateCells; track cell.trackByIndex) {\n          <td\n            title=\"{{ cell.title }}\"\n            role=\"gridcell\"\n            [ngClass]=\"cell.classMap!\"\n            (click)=\"cell.isDisabled ? null : cell.onClick()\"\n            (mouseenter)=\"cell.onMouseEnter()\"\n          >\n            @switch (prefixCls) {\n              @case('ant-picker') {\n                @if(cell.isTemplateRef) {\n                  <ng-container *ngTemplateOutlet=\"$any(cell.cellRender); context: { $implicit: cell.value }\" />\n                }@else if(cell.isNonEmptyString) {\n                  <span [innerHTML]=\"cell.cellRender\"></span>\n                }@else {\n                  <div\n                    class=\"{{ prefixCls }}-cell-inner\"\n                    [attr.aria-selected]=\"cell.isSelected\"\n                    [attr.aria-disabled]=\"cell.isDisabled\"\n                  >\n                    {{ cell.content }}\n                  </div>\n                }\n              }\n              @case('ant-picker-calendar') {\n                <div\n                  class=\"{{ prefixCls }}-date ant-picker-cell-inner\"\n                  [class.ant-picker-calendar-date-today]=\"cell.isToday\"\n                >\n                  @if(cell.fullCellRender) {\n                    <ng-container *ngTemplateOutlet=\"$any(cell.fullCellRender); context: { $implicit: cell.value }\" />\n                  }@else() {\n                    <div class=\"{{ prefixCls }}-date-value\">{{ cell.content }}</div>\n                    <div class=\"{{ prefixCls }}-date-content\">\n                      <ng-container *ngTemplateOutlet=\"$any(cell.cellRender); context: { $implicit: cell.value }\">\n                      </ng-container>\n                    </div>\n                  }\n                </div>\n              }\n            }\n          </td>\n        }\n\n      </tr>\n    }\n  </tbody>\n</table>\n", dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: YearTableComponent, decorators: [{
            type: Component,
            args: [{ encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, selector: 'year-table', exportAs: 'yearTable', imports: [NgIf, NgForOf, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault], standalone: true, template: "<table class=\"ant-picker-content\" cellspacing=\"0\" role=\"grid\">\n  @if(headRow && headRow.length > 0) {\n    <thead>\n      <tr role=\"row\">\n        @if(showWeek) {\n          <th role=\"columnheader\"></th>\n        }\n        @for(cell of headRow; track cell) {\n          <th role=\"columnheader\" title=\"{{ cell.title }}\"> {{ cell.content }} </th>\n        }\n      </tr>\n    </thead>\n  }\n\n  <tbody>\n    @for(row of bodyRows; track row.trackByIndex) {\n      <tr [ngClass]=\"row.classMap!\" role=\"row\">\n        @if(row.weekNum) {\n          <td role=\"gridcell\" class=\"{{ prefixCls }}-cell-week\"> {{ row.weekNum }} </td>\n        }\n        @for(cell of row.dateCells; track cell.trackByIndex) {\n          <td\n            title=\"{{ cell.title }}\"\n            role=\"gridcell\"\n            [ngClass]=\"cell.classMap!\"\n            (click)=\"cell.isDisabled ? null : cell.onClick()\"\n            (mouseenter)=\"cell.onMouseEnter()\"\n          >\n            @switch (prefixCls) {\n              @case('ant-picker') {\n                @if(cell.isTemplateRef) {\n                  <ng-container *ngTemplateOutlet=\"$any(cell.cellRender); context: { $implicit: cell.value }\" />\n                }@else if(cell.isNonEmptyString) {\n                  <span [innerHTML]=\"cell.cellRender\"></span>\n                }@else {\n                  <div\n                    class=\"{{ prefixCls }}-cell-inner\"\n                    [attr.aria-selected]=\"cell.isSelected\"\n                    [attr.aria-disabled]=\"cell.isDisabled\"\n                  >\n                    {{ cell.content }}\n                  </div>\n                }\n              }\n              @case('ant-picker-calendar') {\n                <div\n                  class=\"{{ prefixCls }}-date ant-picker-cell-inner\"\n                  [class.ant-picker-calendar-date-today]=\"cell.isToday\"\n                >\n                  @if(cell.fullCellRender) {\n                    <ng-container *ngTemplateOutlet=\"$any(cell.fullCellRender); context: { $implicit: cell.value }\" />\n                  }@else() {\n                    <div class=\"{{ prefixCls }}-date-value\">{{ cell.content }}</div>\n                    <div class=\"{{ prefixCls }}-date-content\">\n                      <ng-container *ngTemplateOutlet=\"$any(cell.cellRender); context: { $implicit: cell.value }\">\n                      </ng-container>\n                    </div>\n                  }\n                </div>\n              }\n            }\n          </td>\n        }\n\n      </tr>\n    }\n  </tbody>\n</table>\n" }]
        }], ctorParameters: () => [{ type: i1.DateHelperService }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWVhci10YWJsZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb21wb25lbnRzL2RhdGUtcGlja2VyL2xpYi95ZWFyLXRhYmxlLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uL2NvbXBvbmVudHMvZGF0ZS1waWNrZXIvbGliL2Fic3RyYWN0LXRhYmxlLmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztHQUdHO0FBRUgsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUd0RixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUc1RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFFakQsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7OztBQVlwSCxNQUFNLE9BQU8sa0JBQW1CLFNBQVEsYUFBYTtJQUluRCxZQUFvQixVQUE2QjtRQUMvQyxLQUFLLEVBQUUsQ0FBQztRQURVLGVBQVUsR0FBVixVQUFVLENBQW1CO1FBSHhDLFlBQU8sR0FBRyxDQUFDLENBQUM7UUFDWixZQUFPLEdBQUcsQ0FBQyxDQUFDO0lBSXJCLENBQUM7SUFFRCxXQUFXO1FBQ1QsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQsWUFBWTtRQUNWLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNqRSxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsR0FBRyxXQUFXLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzNELE1BQU0sT0FBTyxHQUFHLFNBQVMsR0FBRyxDQUFD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QU8sb0ZBQTBCLGdCQUFnQjs7MkZBRy9ELGtCQUFrQjtrQkFWOUIsU0FBUztvQ0FDTyxpQkFBaUIsQ0FBQyxJQUFJLG1CQUNwQix1QkFBdUIsQ0FBQyxNQUFNLFlBRXJDLFlBQVksWUFDWixXQUFXLFdBRVosQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLGdCQUFnQixFQUFFLGVBQWUsQ0FBQyxjQUNoRixJQUFJIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2dpdGh1Yi5jb20vTkctWk9SUk8vbmctem9ycm8tYW50ZC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2FuZHlEYXRlIH0gZnJvbSAnbmctem9ycm8tYW50ZC9jb3JlL3RpbWUnO1xuaW1wb3J0IHsgdmFsdWVGdW5jdGlvblByb3AgfSBmcm9tICduZy16b3Jyby1hbnRkL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBEYXRlSGVscGVyU2VydmljZSB9IGZyb20gJ25nLXpvcnJvLWFudGQvaTE4bic7XG5cbmltcG9ydCB7IEFic3RyYWN0VGFibGUgfSBmcm9tICcuL2Fic3RyYWN0LXRhYmxlJztcbmltcG9ydCB7IERhdGVCb2R5Um93LCBEYXRlQ2VsbCwgWWVhckNlbGwgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBOZ0NsYXNzLCBOZ0Zvck9mLCBOZ0lmLCBOZ1N3aXRjaCwgTmdTd2l0Y2hDYXNlLCBOZ1N3aXRjaERlZmF1bHQsIE5nVGVtcGxhdGVPdXRsZXQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5AQ29tcG9uZW50KHtcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvY29tcG9uZW50LXNlbGVjdG9yXG4gIHNlbGVjdG9yOiAneWVhci10YWJsZScsXG4gIGV4cG9ydEFzOiAneWVhclRhYmxlJyxcbiAgdGVtcGxhdGVVcmw6ICdhYnN0cmFjdC10YWJsZS5odG1sJyxcbiAgaW1wb3J0czogW05nSWYsIE5nRm9yT2YsIE5nQ2xhc3MsIE5nU3dpdGNoLCBOZ1N3aXRjaENhc2UsIE5nVGVtcGxhdGVPdXRsZXQsIE5nU3dpdGNoRGVmYXVsdF0sXG4gIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgWWVhclRhYmxlQ29tcG9uZW50IGV4dGVuZHMgQWJzdHJhY3RUYWJsZSB7XG4gIG92ZXJyaWRlIE1BWF9ST1cgPSA0O1xuICBvdmVycmlkZSBNQVhfQ09MID0gMztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRhdGVIZWxwZXI6IERhdGVIZWxwZXJTZXJ2aWNlKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIG1ha2VIZWFkUm93KCk6IERhdGVDZWxsW10ge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIG1ha2VCb2R5Um93cygpOiBEYXRlQm9keVJvd1tdIHtcbiAgICBjb25zdCBjdXJyZW50WWVhciA9IHRoaXMuYWN0aXZlRGF0ZSAmJiB0aGlzLmFjdGl2ZURhdGUuZ2V0WWVhcigpO1xuICAgIGNvbnN0IHN0YXJ0WWVhciA9IHBhcnNlSW50KGAke2N1cnJlbnRZZWFyIC8gMTB9YCwgMTApICogMTA7XG4gICAgY29uc3QgZW5kWWVhciA9IHN0YXJ0WWVhciArIDk7XG4gICAgY29uc3QgcHJldmlvdXNZZWFyID0gc3RhcnRZZWFyIC0gMTtcbiAgICBjb25zdCB5ZWFyczogRGF0ZUJvZHlSb3dbXSA9IFtdO1xuICAgIGxldCB5ZWFyVmFsdWUgPSAwO1xuXG4gICAgZm9yIChsZXQgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IHRoaXMuTUFYX1JPVzsgcm93SW5kZXgrKykge1xuICAgICAgY29uc3Qgcm93OiBEYXRlQm9keVJvdyA9IHtcbiAgICAgICAgZGF0ZUNlbGxzOiBbXSxcbiAgICAgICAgdHJhY2tCeUluZGV4OiByb3dJbmRleFxuICAgICAgfTtcbiAgICAgIGZvciAobGV0IGNvbEluZGV4ID0gMDsgY29sSW5kZXggPCB0aGlzLk1BWF9DT0w7IGNvbEluZGV4KyspIHtcbiAgICAgICAgY29uc3QgeWVhck51bSA9IHByZXZpb3VzWWVhciArIHllYXJWYWx1ZTtcbiAgICAgICAgY29uc3QgeWVhciA9IHRoaXMuYWN0aXZlRGF0ZS5zZXRZZWFyKHllYXJOdW0pO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5kYXRlSGVscGVyLmZvcm1hdCh5ZWFyLm5hdGl2ZURhdGUsICd5eXl5Jyk7XG4gICAgICAgIGNvbnN0IGlzRGlzYWJsZWQgPSB0aGlzLmlzRGlzYWJsZWRZZWFyKHllYXIpO1xuICAgICAgICBjb25zdCBjZWxsOiBZZWFyQ2VsbCA9IHtcbiAgICAgICAgICB0cmFja0J5SW5kZXg6IGNvbEluZGV4LFxuICAgICAgICAgIHZhbHVlOiB5ZWFyLm5hdGl2ZURhdGUsXG4gICAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgICBpc1NhbWVEZWNhZGU6IHllYXJOdW0gPj0gc3RhcnRZZWFyICYmIHllYXJOdW0gPD0gZW5kWWVhcixcbiAgICAgICAgICBpc1NlbGVjdGVkOiB5ZWFyTnVtID09PSAodGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmdldFllYXIoKSksXG4gICAgICAgICAgY29udGVudCxcbiAgICAgICAgICB0aXRsZTogY29udGVudCxcbiAgICAgICAgICBjbGFzc01hcDoge30sXG4gICAgICAgICAgaXNMYXN0Q2VsbEluUGFuZWw6IHllYXIuZ2V0WWVhcigpID09PSBlbmRZZWFyLFxuICAgICAgICAgIGlzRmlyc3RDZWxsSW5QYW5lbDogeWVhci5nZXRZZWFyKCkgPT09IHN0YXJ0WWVhcixcbiAgICAgICAgICBjZWxsUmVuZGVyOiB2YWx1ZUZ1bmN0aW9uUHJvcCh0aGlzLmNlbGxSZW5kZXIhLCB5ZWFyKSwgLy8gQ3VzdG9taXplZCBjb250ZW50XG4gICAgICAgICAgZnVsbENlbGxSZW5kZXI6IHZhbHVlRnVuY3Rpb25Qcm9wKHRoaXMuZnVsbENlbGxSZW5kZXIhLCB5ZWFyKSxcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB0aGlzLmNob29zZVllYXIoY2VsbC52YWx1ZS5nZXRGdWxsWWVhcigpKSwgLy8gZG9uJ3QgdXNlIHllYXJWYWx1ZSBoZXJlLFxuICAgICAgICAgIG9uTW91c2VFbnRlcjogKCkgPT4gdGhpcy5jZWxsSG92ZXIuZW1pdCh5ZWFyKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWRkQ2VsbFByb3BlcnR5KGNlbGwsIHllYXIpO1xuICAgICAgICByb3cuZGF0ZUNlbGxzLnB1c2goY2VsbCk7XG4gICAgICAgIHllYXJWYWx1ZSsrO1xuICAgICAgfVxuICAgICAgeWVhcnMucHVzaChyb3cpO1xuICAgIH1cbiAgICByZXR1cm4geWVhcnM7XG4gIH1cblxuICBvdmVycmlkZSBnZXRDbGFzc01hcChjZWxsOiBZZWFyQ2VsbCk6IHsgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZ2V0Q2xhc3NNYXAoY2VsbCksXG4gICAgICBbYGFudC1waWNrZXItY2VsbC1pbi12aWV3YF06ICEhY2VsbC5pc1NhbWVEZWNhZGVcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBpc0Rpc2FibGVkWWVhcih5ZWFyOiBDYW5keURhdGUpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWREYXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RPZk1vbnRoID0geWVhci5zZXRNb250aCgwKS5zZXREYXRlKDEpO1xuXG4gICAgZm9yIChsZXQgZGF0ZSA9IGZpcnN0T2ZNb250aDsgZGF0ZS5nZXRZZWFyKCkgPT09IHllYXIuZ2V0WWVhcigpOyBkYXRlID0gZGF0ZS5hZGREYXlzKDEpKSB7XG4gICAgICBpZiAoIXRoaXMuZGlzYWJsZWREYXRlKGRhdGUubmF0aXZlRGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRDZWxsUHJvcGVydHkoY2VsbDogRGF0ZUNlbGwsIHllYXI6IENhbmR5RGF0ZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhc1JhbmdlVmFsdWUoKSkge1xuICAgICAgY29uc3QgW3N0YXJ0SG92ZXIsIGVuZEhvdmVyXSA9IHRoaXMuaG92ZXJWYWx1ZTtcbiAgICAgIGNvbnN0IFtzdGFydFNlbGVjdGVkLCBlbmRTZWxlY3RlZF0gPSB0aGlzLnNlbGVjdGVkVmFsdWU7XG4gICAgICAvLyBTZWxlY3RlZFxuICAgICAgaWYgKHN0YXJ0U2VsZWN0ZWQ/LmlzU2FtZVllYXIoeWVhcikpIHtcbiAgICAgICAgY2VsbC5pc1NlbGVjdGVkU3RhcnQgPSB0cnVlO1xuICAgICAgICBjZWxsLmlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kU2VsZWN0ZWQ/LmlzU2FtZVllYXIoeWVhcikpIHtcbiAgICAgICAgY2VsbC5pc1NlbGVjdGVkRW5kID0gdHJ1ZTtcbiAgICAgICAgY2VsbC5pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0SG92ZXIgJiYgZW5kSG92ZXIpIHtcbiAgICAgICAgY2VsbC5pc0hvdmVyU3RhcnQgPSBzdGFydEhvdmVyLmlzU2FtZVllYXIoeWVhcik7XG4gICAgICAgIGNlbGwuaXNIb3ZlckVuZCA9IGVuZEhvdmVyLmlzU2FtZVllYXIoeWVhcik7XG4gICAgICAgIGNlbGwuaXNJbkhvdmVyUmFuZ2UgPSBzdGFydEhvdmVyLmlzQmVmb3JlWWVhcih5ZWFyKSAmJiB5ZWFyLmlzQmVmb3JlWWVhcihlbmRIb3Zlcik7XG4gICAgICB9XG4gICAgICBjZWxsLmlzU3RhcnRTaW5nbGUgPSBzdGFydFNlbGVjdGVkICYmICFlbmRTZWxlY3RlZDtcbiAgICAgIGNlbGwuaXNFbmRTaW5nbGUgPSAhc3RhcnRTZWxlY3RlZCAmJiBlbmRTZWxlY3RlZDtcbiAgICAgIGNlbGwuaXNJblNlbGVjdGVkUmFuZ2UgPSBzdGFydFNlbGVjdGVkPy5pc0JlZm9yZVllYXIoeWVhcikgJiYgeWVhcj8uaXNCZWZvcmVZZWFyKGVuZFNlbGVjdGVkKTtcbiAgICAgIGNlbGwuaXNSYW5nZVN0YXJ0TmVhckhvdmVyID0gc3RhcnRTZWxlY3RlZCAmJiBjZWxsLmlzSW5Ib3ZlclJhbmdlO1xuICAgICAgY2VsbC5pc1JhbmdlRW5kTmVhckhvdmVyID0gZW5kU2VsZWN0ZWQgJiYgY2VsbC5pc0luSG92ZXJSYW5nZTtcbiAgICB9IGVsc2UgaWYgKHllYXIuaXNTYW1lWWVhcih0aGlzLnZhbHVlKSkge1xuICAgICAgY2VsbC5pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgY2VsbC5jbGFzc01hcCA9IHRoaXMuZ2V0Q2xhc3NNYXAoY2VsbCk7XG4gIH1cblxuICBwcml2YXRlIGNob29zZVllYXIoeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy52YWx1ZSA9IHRoaXMuYWN0aXZlRGF0ZS5zZXRZZWFyKHllYXIpO1xuICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLnZhbHVlKTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG59XG4iLCI8dGFibGUgY2xhc3M9XCJhbnQtcGlja2VyLWNvbnRlbnRcIiBjZWxsc3BhY2luZz1cIjBcIiByb2xlPVwiZ3JpZFwiPlxuICBAaWYoaGVhZFJvdyAmJiBoZWFkUm93Lmxlbmd0aCA+IDApIHtcbiAgICA8dGhlYWQ+XG4gICAgICA8dHIgcm9sZT1cInJvd1wiPlxuICAgICAgICBAaWYoc2hvd1dlZWspIHtcbiAgICAgICAgICA8dGggcm9sZT1cImNvbHVtbmhlYWRlclwiPjwvdGg+XG4gICAgICAgIH1cbiAgICAgICAgQGZvcihjZWxsIG9mIGhlYWRSb3c7IHRyYWNrIGNlbGwpIHtcbiAgICAgICAgICA8dGggcm9sZT1cImNvbHVtbmhlYWRlclwiIHRpdGxlPVwie3sgY2VsbC50aXRsZSB9fVwiPiB7eyBjZWxsLmNvbnRlbnQgfX0gPC90aD5cbiAgICAgICAgfVxuICAgICAgPC90cj5cbiAgICA8L3RoZWFkPlxuICB9XG5cbiAgPHRib2R5PlxuICAgIEBmb3Iocm93IG9mIGJvZHlSb3dzOyB0cmFjayByb3cudHJhY2tCeUluZGV4KSB7XG4gICAgICA8dHIgW25nQ2xhc3NdPVwicm93LmNsYXNzTWFwIVwiIHJvbGU9XCJyb3dcIj5cbiAgICAgICAgQGlmKHJvdy53ZWVrTnVtKSB7XG4gICAgICAgICAgPHRkIHJvbGU9XCJncmlkY2VsbFwiIGNsYXNzPVwie3sgcHJlZml4Q2xzIH19LWNlbGwtd2Vla1wiPiB7eyByb3cud2Vla051bSB9fSA8L3RkPlxuICAgICAgICB9XG4gICAgICAgIEBmb3IoY2VsbCBvZiByb3cuZGF0ZUNlbGxzOyB0cmFjayBjZWxsLnRyYWNrQnlJbmRleCkge1xuICAgICAgICAgIDx0ZFxuICAgICAgICAgICAgdGl0bGU9XCJ7eyBjZWxsLnRpdGxlIH19XCJcbiAgICAgICAgICAgIHJvbGU9XCJncmlkY2VsbFwiXG4gICAgICAgICAgICBbbmdDbGFzc109XCJjZWxsLmNsYXNzTWFwIVwiXG4gICAgICAgICAgICAoY2xpY2spPVwiY2VsbC5pc0Rpc2FibGVkID8gbnVsbCA6IGNlbGwub25DbGljaygpXCJcbiAgICAgICAgICAgIChtb3VzZWVudGVyKT1cImNlbGwub25Nb3VzZUVudGVyKClcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIEBzd2l0Y2ggKHByZWZpeENscykge1xuICAgICAgICAgICAgICBAY2FzZSgnYW50LXBpY2tlcicpIHtcbiAgICAgICAgICAgICAgICBAaWYoY2VsbC5pc1RlbXBsYXRlUmVmKSB7XG4gICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiJGFueShjZWxsLmNlbGxSZW5kZXIpOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogY2VsbC52YWx1ZSB9XCIgLz5cbiAgICAgICAgICAgICAgICB9QGVsc2UgaWYoY2VsbC5pc05vbkVtcHR5U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICA8c3BhbiBbaW5uZXJIVE1MXT1cImNlbGwuY2VsbFJlbmRlclwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICB9QGVsc2Uge1xuICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInt7IHByZWZpeENscyB9fS1jZWxsLWlubmVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJjZWxsLmlzU2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWRpc2FibGVkXT1cImNlbGwuaXNEaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHt7IGNlbGwuY29udGVudCB9fVxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEBjYXNlKCdhbnQtcGlja2VyLWNhbGVuZGFyJykge1xuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwie3sgcHJlZml4Q2xzIH19LWRhdGUgYW50LXBpY2tlci1jZWxsLWlubmVyXCJcbiAgICAgICAgICAgICAgICAgIFtjbGFzcy5hbnQtcGlja2VyLWNhbGVuZGFyLWRhdGUtdG9kYXldPVwiY2VsbC5pc1RvZGF5XCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBAaWYoY2VsbC5mdWxsQ2VsbFJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiJGFueShjZWxsLmZ1bGxDZWxsUmVuZGVyKTsgY29udGV4dDogeyAkaW1wbGljaXQ6IGNlbGwudmFsdWUgfVwiIC8+XG4gICAgICAgICAgICAgICAgICB9QGVsc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ7eyBwcmVmaXhDbHMgfX0tZGF0ZS12YWx1ZVwiPnt7IGNlbGwuY29udGVudCB9fTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwie3sgcHJlZml4Q2xzIH19LWRhdGUtY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCIkYW55KGNlbGwuY2VsbFJlbmRlcik7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiBjZWxsLnZhbHVlIH1cIj5cbiAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L3RkPlxuICAgICAgICB9XG5cbiAgICAgIDwvdHI+XG4gICAgfVxuICA8L3Rib2R5PlxuPC90YWJsZT5cbiJdfQ==