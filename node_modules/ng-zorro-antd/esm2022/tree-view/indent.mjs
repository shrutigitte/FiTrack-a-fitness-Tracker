/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { NgForOf } from '@angular/common';
import { ChangeDetectionStrategy, Component, Directive, Input } from '@angular/core';
import { animationFrameScheduler, asapScheduler, merge } from 'rxjs';
import { auditTime } from 'rxjs/operators';
import { getNextSibling, getParent } from './utils';
import * as i0 from "@angular/core";
import * as i1 from "./node-base";
import * as i2 from "./tree";
/**
 * [true, false, false, true] => 1001
 */
function booleanArrayToString(arr) {
    return arr.map(i => (i ? 1 : 0)).join('');
}
const BUILD_INDENTS_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;
export class NzTreeNodeIndentsComponent {
    constructor() {
        this.indents = [];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: NzTreeNodeIndentsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.1.2", type: NzTreeNodeIndentsComponent, isStandalone: true, selector: "nz-tree-node-indents", inputs: { indents: "indents" }, host: { classAttribute: "ant-tree-indent" }, ngImport: i0, template: `
    <span class="ant-tree-indent-unit" [class.ant-tree-indent-unit-end]="!isEnd" *ngFor="let isEnd of indents"></span>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: NzTreeNodeIndentsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-tree-node-indents',
                    template: `
    <span class="ant-tree-indent-unit" [class.ant-tree-indent-unit-end]="!isEnd" *ngFor="let isEnd of indents"></span>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        class: 'ant-tree-indent'
                    },
                    imports: [NgForOf],
                    standalone: true
                }]
        }], propDecorators: { indents: [{
                type: Input
            }] } });
export class NzTreeNodeIndentLineDirective {
    constructor(treeNode, tree, cdr) {
        this.treeNode = treeNode;
        this.tree = tree;
        this.cdr = cdr;
        this.isLast = 'unset';
        this.isLeaf = false;
        this.preNodeRef = null;
        this.nextNodeRef = null;
        this.currentIndents = '';
        this.buildIndents();
        this.checkLast();
        /**
         * The dependent data (TreeControl.dataNodes) can be set after node instantiation,
         * and setting the indents can cause frame rate loss if it is set too often.
         */
        this.changeSubscription = merge(this.treeNode._dataChanges, tree._dataSourceChanged)
            .pipe(auditTime(0, BUILD_INDENTS_SCHEDULER))
            .subscribe(() => {
            this.buildIndents();
            this.checkAdjacent();
            this.cdr.markForCheck();
        });
    }
    getIndents() {
        const indents = [];
        const nodes = this.tree.treeControl.dataNodes;
        const getLevel = this.tree.treeControl.getLevel;
        let parent = getParent(nodes, this.treeNode.data, getLevel);
        while (parent) {
            const parentNextSibling = getNextSibling(nodes, parent, getLevel);
            if (parentNextSibling) {
                indents.unshift(true);
            }
            else {
                indents.unshift(false);
            }
            parent = getParent(nodes, parent, getLevel);
        }
        return indents;
    }
    buildIndents() {
        if (this.treeNode.data) {
            const indents = this.getIndents();
            const diffString = booleanArrayToString(indents);
            if (diffString !== this.currentIndents) {
                this.treeNode.setIndents(this.getIndents());
                this.currentIndents = diffString;
            }
        }
    }
    /**
     * We need to add an class name for the last child node,
     * this result can also be affected when the adjacent nodes are changed.
     */
    checkAdjacent() {
        const nodes = this.tree.treeControl.dataNodes;
        const index = nodes.indexOf(this.treeNode.data);
        const preNode = nodes[index - 1] || null;
        const nextNode = nodes[index + 1] || null;
        if (this.nextNodeRef !== nextNode || this.preNodeRef !== preNode) {
            this.checkLast(index);
        }
        this.preNodeRef = preNode;
        this.nextNodeRef = nextNode;
    }
    checkLast(index) {
        const nodes = this.tree.treeControl.dataNodes;
        this.isLeaf = this.treeNode.isLeaf;
        this.isLast = !getNextSibling(nodes, this.treeNode.data, this.tree.treeControl.getLevel, index);
    }
    ngOnDestroy() {
        this.preNodeRef = null;
        this.nextNodeRef = null;
        this.changeSubscription.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: NzTreeNodeIndentLineDirective, deps: [{ token: i1.NzNodeBase }, { token: i2.NzTreeView }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.1.2", type: NzTreeNodeIndentLineDirective, isStandalone: true, selector: "nz-tree-node[nzTreeNodeIndentLine]", host: { properties: { "class.ant-tree-treenode-leaf-last": "isLast && isLeaf" }, classAttribute: "ant-tree-show-line" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: NzTreeNodeIndentLineDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'nz-tree-node[nzTreeNodeIndentLine]',
                    host: {
                        class: 'ant-tree-show-line',
                        '[class.ant-tree-treenode-leaf-last]': 'isLast && isLeaf'
                    },
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.NzNodeBase }, { type: i2.NzTreeView }, { type: i0.ChangeDetectorRef }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vY29tcG9uZW50cy90cmVlLXZpZXcvaW5kZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRztBQUVILE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMxQyxPQUFPLEVBQUUsdUJBQXVCLEVBQXFCLFNBQVMsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQ25ILE9BQU8sRUFBZ0IsdUJBQXVCLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNuRixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFJM0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxTQUFTLEVBQUUsTUFBTSxTQUFTLENBQUM7Ozs7QUFFcEQ7O0dBRUc7QUFDSCxTQUFTLG9CQUFvQixDQUFDLEdBQWM7SUFDMUMsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDNUMsQ0FBQztBQUVELE1BQU0sdUJBQXVCLEdBQUcsT0FBTyxxQkFBcUIsS0FBSyxXQUFXLENBQUMsQ0FBQyxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUM7QUFjdkgsTUFBTSxPQUFPLDBCQUEwQjtJQVp2QztRQWFXLFlBQU8sR0FBYyxFQUFFLENBQUM7S0FDbEM7OEdBRlksMEJBQTBCO2tHQUExQiwwQkFBMEIsNkpBVjNCOztHQUVULDREQUtTLE9BQU87OzJGQUdOLDBCQUEwQjtrQkFadEMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsc0JBQXNCO29CQUNoQyxRQUFRLEVBQUU7O0dBRVQ7b0JBQ0QsZUFBZSxFQUFF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QUNULFFBQVEsRUFBRSxvQ0FBb0M7b0JBQzlDLElBQUksRUFBRTt3QkFDSixLQUFLLEVBQUUsb0JBQW9CO3dCQUMzQixxQ0FBcUMsRUFBRSxrQkFBa0I7cUJBQzFEO29CQUNELFVBQVUsRUFBRSxJQUFJO2lCQUNqQiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9naXRodWIuY29tL05HLVpPUlJPL25nLXpvcnJvLWFudGQvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbmltcG9ydCB7IE5nRm9yT2YgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIERpcmVjdGl2ZSwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlciwgYXNhcFNjaGVkdWxlciwgbWVyZ2UgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGF1ZGl0VGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgTnpOb2RlQmFzZSB9IGZyb20gJy4vbm9kZS1iYXNlJztcbmltcG9ydCB7IE56VHJlZVZpZXcgfSBmcm9tICcuL3RyZWUnO1xuaW1wb3J0IHsgZ2V0TmV4dFNpYmxpbmcsIGdldFBhcmVudCB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIFt0cnVlLCBmYWxzZSwgZmFsc2UsIHRydWVdID0+IDEwMDFcbiAqL1xuZnVuY3Rpb24gYm9vbGVhbkFycmF5VG9TdHJpbmcoYXJyOiBib29sZWFuW10pOiBzdHJpbmcge1xuICByZXR1cm4gYXJyLm1hcChpID0+IChpID8gMSA6IDApKS5qb2luKCcnKTtcbn1cblxuY29uc3QgQlVJTERfSU5ERU5UU19TQ0hFRFVMRVIgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAndW5kZWZpbmVkJyA/IGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyIDogYXNhcFNjaGVkdWxlcjtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbnotdHJlZS1ub2RlLWluZGVudHMnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxzcGFuIGNsYXNzPVwiYW50LXRyZWUtaW5kZW50LXVuaXRcIiBbY2xhc3MuYW50LXRyZWUtaW5kZW50LXVuaXQtZW5kXT1cIiFpc0VuZFwiICpuZ0Zvcj1cImxldCBpc0VuZCBvZiBpbmRlbnRzXCI+PC9zcGFuPlxuICBgLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnYW50LXRyZWUtaW5kZW50J1xuICB9LFxuICBpbXBvcnRzOiBbTmdGb3JPZl0sXG4gIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgTnpUcmVlTm9kZUluZGVudHNDb21wb25lbnQge1xuICBASW5wdXQoKSBpbmRlbnRzOiBib29sZWFuW10gPSBbXTtcbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnbnotdHJlZS1ub2RlW256VHJlZU5vZGVJbmRlbnRMaW5lXScsXG4gIGhvc3Q6IHtcbiAgICBjbGFzczogJ2FudC10cmVlLXNob3ctbGluZScsXG4gICAgJ1tjbGFzcy5hbnQtdHJlZS10cmVlbm9kZS1sZWFmLWxhc3RdJzogJ2lzTGFzdCAmJiBpc0xlYWYnXG4gIH0sXG4gIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgTnpUcmVlTm9kZUluZGVudExpbmVEaXJlY3RpdmU8VD4gaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBpc0xhc3Q6IGJvb2xlYW4gfCAndW5zZXQnID0gJ3Vuc2V0JztcbiAgaXNMZWFmID0gZmFsc2U7XG4gIHByaXZhdGUgcHJlTm9kZVJlZjogVCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIG5leHROb2RlUmVmOiBUIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgY3VycmVudEluZGVudHM6IHN0cmluZyA9ICcnO1xuICBwcml2YXRlIGNoYW5nZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdHJlZU5vZGU6IE56Tm9kZUJhc2U8VD4sXG4gICAgcHJpdmF0ZSB0cmVlOiBOelRyZWVWaWV3PFQ+LFxuICAgIHByaXZhdGUgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZlxuICApIHtcbiAgICB0aGlzLmJ1aWxkSW5kZW50cygpO1xuICAgIHRoaXMuY2hlY2tMYXN0KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVwZW5kZW50IGRhdGEgKFRyZWVDb250cm9sLmRhdGFOb2RlcykgY2FuIGJlIHNldCBhZnRlciBub2RlIGluc3RhbnRpYXRpb24sXG4gICAgICogYW5kIHNldHRpbmcgdGhlIGluZGVudHMgY2FuIGNhdXNlIGZyYW1lIHJhdGUgbG9zcyBpZiBpdCBpcyBzZXQgdG9vIG9mdGVuLlxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdlU3Vic2NyaXB0aW9uID0gbWVyZ2UodGhpcy50cmVlTm9kZS5fZGF0YUNoYW5nZXMsIHRyZWUuX2RhdGFTb3VyY2VDaGFuZ2VkKVxuICAgICAgLnBpcGUoYXVkaXRUaW1lKDAsIEJVSUxEX0lOREVOVFNfU0NIRURVTEVSKSlcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLmJ1aWxkSW5kZW50cygpO1xuICAgICAgICB0aGlzLmNoZWNrQWRqYWNlbnQoKTtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0SW5kZW50cygpOiBib29sZWFuW10ge1xuICAgIGNvbnN0IGluZGVudHMgPSBbXTtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMudHJlZS50cmVlQ29udHJvbC5kYXRhTm9kZXM7XG4gICAgY29uc3QgZ2V0TGV2ZWwgPSB0aGlzLnRyZWUudHJlZUNvbnRyb2wuZ2V0TGV2ZWw7XG4gICAgbGV0IHBhcmVudCA9IGdldFBhcmVudChub2RlcywgdGhpcy50cmVlTm9kZS5kYXRhLCBnZXRMZXZlbCk7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgY29uc3QgcGFyZW50TmV4dFNpYmxpbmcgPSBnZXROZXh0U2libGluZyhub2RlcywgcGFyZW50LCBnZXRMZXZlbCk7XG4gICAgICBpZiAocGFyZW50TmV4dFNpYmxpbmcpIHtcbiAgICAgICAgaW5kZW50cy51bnNoaWZ0KHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZW50cy51bnNoaWZ0KGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IGdldFBhcmVudChub2RlcywgcGFyZW50LCBnZXRMZXZlbCk7XG4gICAgfVxuICAgIHJldHVybiBpbmRlbnRzO1xuICB9XG5cbiAgcHJpdmF0ZSBidWlsZEluZGVudHMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudHJlZU5vZGUuZGF0YSkge1xuICAgICAgY29uc3QgaW5kZW50cyA9IHRoaXMuZ2V0SW5kZW50cygpO1xuICAgICAgY29uc3QgZGlmZlN0cmluZyA9IGJvb2xlYW5BcnJheVRvU3RyaW5nKGluZGVudHMpO1xuICAgICAgaWYgKGRpZmZTdHJpbmcgIT09IHRoaXMuY3VycmVudEluZGVudHMpIHtcbiAgICAgICAgdGhpcy50cmVlTm9kZS5zZXRJbmRlbnRzKHRoaXMuZ2V0SW5kZW50cygpKTtcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZW50cyA9IGRpZmZTdHJpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdlIG5lZWQgdG8gYWRkIGFuIGNsYXNzIG5hbWUgZm9yIHRoZSBsYXN0IGNoaWxkIG5vZGUsXG4gICAqIHRoaXMgcmVzdWx0IGNhbiBhbHNvIGJlIGFmZmVjdGVkIHdoZW4gdGhlIGFkamFjZW50IG5vZGVzIGFyZSBjaGFuZ2VkLlxuICAgKi9cbiAgcHJpdmF0ZSBjaGVja0FkamFjZW50KCk6IHZvaWQge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy50cmVlLnRyZWVDb250cm9sLmRhdGFOb2RlcztcbiAgICBjb25zdCBpbmRleCA9IG5vZGVzLmluZGV4T2YodGhpcy50cmVlTm9kZS5kYXRhKTtcbiAgICBjb25zdCBwcmVOb2RlID0gbm9kZXNbaW5kZXggLSAxXSB8fCBudWxsO1xuICAgIGNvbnN0IG5leHROb2RlID0gbm9kZXNbaW5kZXggKyAxXSB8fCBudWxsO1xuICAgIGlmICh0aGlzLm5leHROb2RlUmVmICE9PSBuZXh0Tm9kZSB8fCB0aGlzLnByZU5vZGVSZWYgIT09IHByZU5vZGUpIHtcbiAgICAgIHRoaXMuY2hlY2tMYXN0KGluZGV4KTtcbiAgICB9XG4gICAgdGhpcy5wcmVOb2RlUmVmID0gcHJlTm9kZTtcbiAgICB0aGlzLm5leHROb2RlUmVmID0gbmV4dE5vZGU7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrTGFzdChpbmRleD86IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy50cmVlLnRyZWVDb250cm9sLmRhdGFOb2RlcztcbiAgICB0aGlzLmlzTGVhZiA9IHRoaXMudHJlZU5vZGUuaXNMZWFmO1xuICAgIHRoaXMuaXNMYXN0ID0gIWdldE5leHRTaWJsaW5nKG5vZGVzLCB0aGlzLnRyZWVOb2RlLmRhdGEsIHRoaXMudHJlZS50cmVlQ29udHJvbC5nZXRMZXZlbCwgaW5kZXgpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5wcmVOb2RlUmVmID0gbnVsbDtcbiAgICB0aGlzLm5leHROb2RlUmVmID0gbnVsbDtcbiAgICB0aGlzLmNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iXX0=