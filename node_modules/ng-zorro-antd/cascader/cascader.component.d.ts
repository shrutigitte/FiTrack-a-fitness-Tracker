/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { Direction, Directionality } from '@angular/cdk/bidi';
import { CdkConnectedOverlay, ConnectionPositionPair } from '@angular/cdk/overlay';
import { ChangeDetectorRef, ElementRef, EventEmitter, NgZone, OnChanges, OnDestroy, OnInit, QueryList, Renderer2, SimpleChanges, TemplateRef } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { Observable } from 'rxjs';
import { NzConfigKey, NzConfigService } from 'ng-zorro-antd/core/config';
import { NzFormStatusService } from 'ng-zorro-antd/core/form';
import { NzNoAnimationDirective } from 'ng-zorro-antd/core/no-animation';
import { NzDestroyService } from 'ng-zorro-antd/core/services';
import { NgClassInterface, NgClassType, NgStyleInterface, NzSafeAny, NzStatus, NzValidateStatus } from 'ng-zorro-antd/core/types';
import { NzCascaderI18nInterface, NzI18nService } from 'ng-zorro-antd/i18n';
import { NzCascaderOptionComponent } from './cascader-li.component';
import { NzCascaderService } from './cascader.service';
import { NzCascaderComponentAsSource, NzCascaderExpandTrigger, NzCascaderOption, NzCascaderSize, NzCascaderTriggerType, NzShowSearchOptions } from './typings';
import * as i0 from "@angular/core";
export declare class NzCascaderComponent implements NzCascaderComponentAsSource, OnInit, OnDestroy, OnChanges, ControlValueAccessor {
    cascaderService: NzCascaderService;
    nzConfigService: NzConfigService;
    private ngZone;
    private cdr;
    private i18nService;
    private destroy$;
    private elementRef;
    private renderer;
    private directionality;
    readonly _nzModuleName: NzConfigKey;
    selectContainer: ElementRef;
    set input(input: ElementRef<HTMLInputElement> | undefined);
    get input(): ElementRef<HTMLInputElement> | undefined;
    /** Used to store the native `<input type="search" />` element since it might be set asynchronously. */
    private input$;
    menu: ElementRef;
    overlay: CdkConnectedOverlay;
    cascaderItems: QueryList<NzCascaderOptionComponent>;
    nzOptionRender: TemplateRef<{
        $implicit: NzCascaderOption;
        index: number;
    }> | null;
    nzShowInput: boolean;
    nzShowArrow: boolean;
    nzAllowClear: boolean;
    nzAutoFocus: boolean;
    nzChangeOnSelect: boolean;
    nzDisabled: boolean;
    nzColumnClassName?: string;
    nzExpandTrigger: NzCascaderExpandTrigger;
    nzValueProperty: string;
    nzLabelRender: TemplateRef<typeof this.labelRenderContext> | null;
    nzLabelProperty: string;
    nzNotFoundContent?: string | TemplateRef<void>;
    nzSize: NzCascaderSize;
    nzBackdrop: boolean;
    nzShowSearch: boolean | NzShowSearchOptions;
    nzPlaceHolder: string;
    nzMenuClassName?: string;
    nzMenuStyle: NgStyleInterface | null;
    nzMouseEnterDelay: number;
    nzMouseLeaveDelay: number;
    nzStatus: NzStatus;
    nzTriggerAction: NzCascaderTriggerType | NzCascaderTriggerType[];
    nzChangeOn?: (option: NzCascaderOption, level: number) => boolean;
    nzLoadData?: (node: NzCascaderOption, index: number) => PromiseLike<NzSafeAny> | Observable<NzSafeAny>;
    nzSuffixIcon: string | TemplateRef<void>;
    nzExpandIcon: string | TemplateRef<void>;
    get nzOptions(): NzCascaderOption[] | null;
    set nzOptions(options: NzCascaderOption[] | null);
    readonly nzVisibleChange: EventEmitter<boolean>;
    readonly nzSelectionChange: EventEmitter<NzCascaderOption[]>;
    readonly nzSelect: EventEmitter<{
        option: NzCascaderOption;
        index: number;
    } | null>;
    readonly nzClear: EventEmitter<void>;
    prefixCls: string;
    statusCls: NgClassInterface;
    status: NzValidateStatus;
    hasFeedback: boolean;
    /**
     * If the dropdown should show the empty content.
     * `true` if there's no options.
     */
    shouldShowEmpty: boolean;
    el: HTMLElement;
    menuVisible: boolean;
    isLoading: boolean;
    labelRenderText?: string;
    labelRenderContext: {};
    onChange: Function;
    onTouched: Function;
    positions: ConnectionPositionPair[];
    /**
     * Dropdown's with in pixel.
     */
    dropdownWidthStyle?: string;
    dropdownHeightStyle: 'auto' | '';
    isFocused: boolean;
    locale: NzCascaderI18nInterface;
    dir: Direction;
    isComposing: boolean;
    private inputString;
    private isOpening;
    private delayMenuTimer?;
    private delaySelectTimer?;
    private isNzDisableFirstChange;
    get inSearchingMode(): boolean;
    set inputValue(inputValue: string);
    get inputValue(): string;
    get menuCls(): NgClassType;
    get menuColumnCls(): NgClassType;
    private get hasInput();
    private get hasValue();
    get showLabelRender(): boolean;
    get showPlaceholder(): boolean;
    get clearIconVisible(): boolean;
    get isLabelRenderTemplate(): boolean;
    noAnimation: NzNoAnimationDirective | null;
    nzFormStatusService: NzFormStatusService | null;
    private nzFormNoStatusService;
    constructor(cascaderService: NzCascaderService, nzConfigService: NzConfigService, ngZone: NgZone, cdr: ChangeDetectorRef, i18nService: NzI18nService, destroy$: NzDestroyService, elementRef: ElementRef, renderer: Renderer2, directionality: Directionality);
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    registerOnChange(fn: () => {}): void;
    registerOnTouched(fn: () => {}): void;
    writeValue(value: NzSafeAny): void;
    delaySetMenuVisible(visible: boolean, delay?: number, setOpening?: boolean): void;
    setMenuVisible(visible: boolean): void;
    private clearDelayMenuTimer;
    clearSelection(event?: Event): void;
    getSubmitValue(): NzSafeAny[];
    focus(): void;
    blur(): void;
    handleInputBlur(): void;
    handleInputFocus(): void;
    handleInputCompositionstart(): void;
    handleInputCompositionend(): void;
    onTriggerClick(): void;
    onTriggerMouseEnter(): void;
    onTriggerMouseLeave(event: MouseEvent): void;
    onOptionMouseEnter(option: NzCascaderOption, columnIndex: number, event: Event): void;
    onOptionMouseLeave(option: NzCascaderOption, _columnIndex: number, event: Event): void;
    onOptionClick(option: NzCascaderOption, columnIndex: number, event: Event): void;
    onClickOutside(event: MouseEvent): void;
    private isActionTrigger;
    private onEnter;
    private moveUpOrDown;
    private moveLeft;
    private moveRight;
    private clearDelaySelectTimer;
    private delaySetOptionActivated;
    private toggleSearchingMode;
    isOptionActivated(option: NzCascaderOption, index: number): boolean;
    setDisabledState(isDisabled: boolean): void;
    closeMenu(): void;
    /**
     * Reposition the cascader panel. When a menu opens, the cascader expands
     * and may exceed the boundary of browser's window.
     */
    private reposition;
    /**
     * When a cascader options is changed, a child needs to know that it should re-render.
     */
    private checkChildren;
    private setDisplayLabel;
    private setDropdownStyles;
    private setStatusStyles;
    private setLocale;
    private scrollToActivatedOptions;
    private setupChangeListener;
    private setupKeydownListener;
    static ɵfac: i0.ɵɵFactoryDeclaration<NzCascaderComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NzCascaderComponent, "nz-cascader, [nz-cascader]", ["nzCascader"], { "nzOptionRender": { "alias": "nzOptionRender"; "required": false; }; "nzShowInput": { "alias": "nzShowInput"; "required": false; }; "nzShowArrow": { "alias": "nzShowArrow"; "required": false; }; "nzAllowClear": { "alias": "nzAllowClear"; "required": false; }; "nzAutoFocus": { "alias": "nzAutoFocus"; "required": false; }; "nzChangeOnSelect": { "alias": "nzChangeOnSelect"; "required": false; }; "nzDisabled": { "alias": "nzDisabled"; "required": false; }; "nzColumnClassName": { "alias": "nzColumnClassName"; "required": false; }; "nzExpandTrigger": { "alias": "nzExpandTrigger"; "required": false; }; "nzValueProperty": { "alias": "nzValueProperty"; "required": false; }; "nzLabelRender": { "alias": "nzLabelRender"; "required": false; }; "nzLabelProperty": { "alias": "nzLabelProperty"; "required": false; }; "nzNotFoundContent": { "alias": "nzNotFoundContent"; "required": false; }; "nzSize": { "alias": "nzSize"; "required": false; }; "nzBackdrop": { "alias": "nzBackdrop"; "required": false; }; "nzShowSearch": { "alias": "nzShowSearch"; "required": false; }; "nzPlaceHolder": { "alias": "nzPlaceHolder"; "required": false; }; "nzMenuClassName": { "alias": "nzMenuClassName"; "required": false; }; "nzMenuStyle": { "alias": "nzMenuStyle"; "required": false; }; "nzMouseEnterDelay": { "alias": "nzMouseEnterDelay"; "required": false; }; "nzMouseLeaveDelay": { "alias": "nzMouseLeaveDelay"; "required": false; }; "nzStatus": { "alias": "nzStatus"; "required": false; }; "nzTriggerAction": { "alias": "nzTriggerAction"; "required": false; }; "nzChangeOn": { "alias": "nzChangeOn"; "required": false; }; "nzLoadData": { "alias": "nzLoadData"; "required": false; }; "nzSuffixIcon": { "alias": "nzSuffixIcon"; "required": false; }; "nzExpandIcon": { "alias": "nzExpandIcon"; "required": false; }; "nzOptions": { "alias": "nzOptions"; "required": false; }; }, { "nzVisibleChange": "nzVisibleChange"; "nzSelectionChange": "nzSelectionChange"; "nzSelect": "nzSelect"; "nzClear": "nzClear"; }, never, ["*"], true, never>;
    static ngAcceptInputType_nzShowInput: unknown;
    static ngAcceptInputType_nzShowArrow: unknown;
    static ngAcceptInputType_nzAllowClear: unknown;
    static ngAcceptInputType_nzAutoFocus: unknown;
    static ngAcceptInputType_nzChangeOnSelect: unknown;
    static ngAcceptInputType_nzDisabled: unknown;
    static ngAcceptInputType_nzMouseEnterDelay: unknown;
    static ngAcceptInputType_nzMouseLeaveDelay: unknown;
}
